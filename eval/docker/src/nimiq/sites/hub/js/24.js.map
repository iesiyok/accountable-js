{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-sign-transaction-nimiq.es.js","sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-with-key-path-nimiq.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8F;AACjB;AACnC;AACN;;AAEpC,0CAA0C,+EAAuB;AACjE;AACA,qBAAqB,kEAAgB;AACrC,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS;AAC1C;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS;AAC1C;AACA;AACA;AACA;;AAEe,0FAA2B,EAAC;AAC3C;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAqE;AACY;;AAEjF,sCAAsC,iEAAY;AAClD,oEAAoE;AACpE;AACA;AACA;AACA,gBAAgB,wEAAc,mBAAmB,sDAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8CAA8C,QAAQ,IAAI,eAAe;AACnH;AACA;AACA;;AAEwC;AACxC","file":"js/24.js","sourcesContent":["import { R as RequestWithKeyPathNimiq } from './lazy-chunk-request-with-key-path-nimiq.es.js';\nimport { RequestTypeNimiq, ErrorState, ErrorType } from './ledger-api.es.js';\nimport './lazy-chunk-request-nimiq.es.js';\nimport './lazy-chunk-request.es.js';\n\nclass RequestSignTransactionNimiq extends RequestWithKeyPathNimiq {\n    constructor(keyPath, transaction, expectedWalletId) {\n        const type = RequestTypeNimiq.SIGN_TRANSACTION;\n        super(keyPath, expectedWalletId, { type });\n        this.type = type;\n        this.transaction = transaction;\n        // Preload Nimiq lib. Ledger Nimiq api is already preloaded by parent class. Ignore errors.\n        this._loadNimiq().catch(() => { });\n    }\n    async call(transport) {\n        const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED on failure\n        // Note: We make api calls outside of try...catch blocks to let the exceptions fall through such that\n        // _callLedger can decide how to behave depending on the api error. All other errors are converted to\n        // REQUEST_ASSERTION_FAILED errors which stop the execution of the request.\n        const { publicKey: signerPubKeyBytes } = await api.getPublicKey(this.keyPath, true, // validate\n        false);\n        const Nimiq = await this._loadNimiq(); // throws LOADING_DEPENDENCIES_FAILED on failure\n        let nimiqTx;\n        let signerPubKey;\n        try {\n            const tx = this.transaction;\n            signerPubKey = new Nimiq.PublicKey(signerPubKeyBytes);\n            const senderType = tx.senderType !== undefined && tx.senderType !== null\n                ? tx.senderType\n                : Nimiq.Account.Type.BASIC;\n            const recipientType = tx.recipientType !== undefined && tx.recipientType !== null\n                ? tx.recipientType\n                : Nimiq.Account.Type.BASIC;\n            let { network } = tx;\n            if (!network) {\n                try {\n                    network = Nimiq.GenesisConfig.NETWORK_NAME;\n                }\n                catch (e) {\n                    // Genesis config not initialized\n                    network = 'main';\n                }\n            }\n            const genesisConfig = Nimiq.GenesisConfig.CONFIGS[network];\n            const networkId = genesisConfig.NETWORK_ID;\n            const flags = tx.flags !== undefined && tx.flags !== null\n                ? tx.flags\n                : Nimiq.Transaction.Flag.NONE;\n            const fee = tx.fee || 0;\n            if ((tx.extraData && tx.extraData.length !== 0)\n                || senderType !== Nimiq.Account.Type.BASIC\n                || recipientType !== Nimiq.Account.Type.BASIC\n                || flags !== Nimiq.Transaction.Flag.NONE) {\n                const extraData = tx.extraData ? tx.extraData : new Uint8Array(0);\n                nimiqTx = new Nimiq.ExtendedTransaction(tx.sender, senderType, tx.recipient, recipientType, tx.value, fee, tx.validityStartHeight, flags, extraData, \n                /* proof */ undefined, networkId);\n            }\n            else {\n                nimiqTx = new Nimiq.BasicTransaction(signerPubKey, tx.recipient, tx.value, fee, tx.validityStartHeight, /* signature */ undefined, networkId);\n            }\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, e, this);\n        }\n        const { signature: signatureBytes } = await api.signTransaction(this.keyPath, nimiqTx.serializeContent());\n        try {\n            const signature = new Nimiq.Signature(signatureBytes);\n            if (nimiqTx instanceof Nimiq.BasicTransaction) {\n                nimiqTx.signature = signature;\n            }\n            else {\n                nimiqTx.proof = Nimiq.SignatureProof.singleSig(signerPubKey, signature).serialize();\n            }\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, e, this);\n        }\n        return nimiqTx;\n    }\n}\n\nexport default RequestSignTransactionNimiq;\n//# sourceMappingURL=lazy-chunk-request-sign-transaction-nimiq.es.js.map\n","import { R as RequestNimiq } from './lazy-chunk-request-nimiq.es.js';\nimport { parseBip32Path, Coin, ErrorState, ErrorType } from './ledger-api.es.js';\n\nclass RequestWithKeyPathNimiq extends RequestNimiq {\n    constructor(keyPath, expectedWalletId, childClassProperties = {}) {\n        super(expectedWalletId);\n        this.keyPath = keyPath;\n        try {\n            if (parseBip32Path(keyPath).coin !== Coin.NIMIQ)\n                throw new Error('Not a Nimiq bip32 path');\n        }\n        catch (e) {\n            // Set properties of child class such that these are present on the request in the thrown error state.\n            for (const [key, value] of Object.entries(childClassProperties)) {\n                this[key] = value;\n            }\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}: ${e.message || e}`, this);\n        }\n    }\n}\n\nexport { RequestWithKeyPathNimiq as R };\n//# sourceMappingURL=lazy-chunk-request-with-key-path-nimiq.es.js.map\n"],"sourceRoot":""}