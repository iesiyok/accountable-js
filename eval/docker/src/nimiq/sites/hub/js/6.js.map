{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAuG;;AAEvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD,wDAAwD;AACxD,sBAAsB,4DAAU,CAAC,2DAAS,oCAAoC,IAAI,cAAc,iBAAiB;AACjH;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,yBAAyB,IAAI,oBAAoB,WAAW,cAAc,2BAA2B;AAC/I;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAU,CAAC,2DAAS;AACtC;AACA;AACA,uBAAuB,mDAAoB;;AAEQ;AACnD","file":"js/6.js","sourcesContent":["import { O as Observable, ErrorState, ErrorType, R as REQUEST_EVENT_CANCEL } from './ledger-api.es.js';\n\n// Also see https://github.com/LedgerHQ/ledgerjs/issues/365 for other requests which might be interesting.\nasync function getAppNameAndVersion(transport, scrambleKey) {\n    // Taken from @ledgerhq/hw-app-btc/getAppAndVersion.js. We don't import it directly from there to avoid loading its\n    // unnecessary dependencies. Note that this request is common to all apps and the dashboard and is no Bitcoin app\n    // specific request (it's not on https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc but rather imple-\n    // mented in the Ledger Nano S and Nano X SDKs, see os_io_seproxyhal.c. Also mind the different cla). However, for\n    // u2f and WebAuthn the used scramble key must match the one of the connected app for the Ledger to answer the\n    // request. Therefore, decorate the api method manually to make it compatible with all apps, not only the Nimiq app.\n    const getAppNameAndVersionApi = {\n        async getAppNameAndVersion() {\n            // Note that no u2f heartbeat is required here as the call is not interactive but answers directly.\n            const response = await transport.send(0xb0, 0x01, 0x00, 0x00);\n            const status = response.slice(response.length - 2).readUInt16BE(0);\n            if (status !== 0x9000)\n                throw new Error('getAppNameAndVersion failed'); // should not actually happen\n            let offset = 0;\n            const format = response[offset++];\n            if (format !== 1)\n                throw new Error('Unsupported format');\n            const nameLength = response[offset++];\n            const name = response.slice(offset, (offset += nameLength)).toString('ascii');\n            const versionLength = response[offset++];\n            const version = response.slice(offset, (offset += versionLength)).toString('ascii');\n            return { name, version };\n        },\n    };\n    // Takes care of setting the api lock (for ledger busy errors) and scramble key. Note that decorating the api method\n    // does not modify the transport instance, therefore decorating on each invocation of getAppNameAndVersion does no\n    // harm. Also note that the lock is a property of the transport, thus works correctly across multiple independently\n    // decorated methods.\n    transport.decorateAppAPIMethods(getAppNameAndVersionApi, ['getAppNameAndVersion'], scrambleKey);\n    return getAppNameAndVersionApi.getAppNameAndVersion();\n}\n\nclass Request extends Observable {\n    constructor(expectedWalletId) {\n        super();\n        this._cancelled = false;\n        this.expectedWalletId = expectedWalletId;\n    }\n    static _isAppVersionSupported(versionString, minRequiredVersion) {\n        const version = versionString.split('.').map((part) => parseInt(part, 10));\n        const parsedMinRequiredVersion = minRequiredVersion.split('.').map((part) => parseInt(part, 10));\n        for (let i = 0; i < minRequiredVersion.length; ++i) {\n            if (typeof version[i] === 'undefined' || version[i] < parsedMinRequiredVersion[i])\n                return false;\n            if (version[i] > parsedMinRequiredVersion[i])\n                return true;\n        }\n        return true;\n    }\n    get cancelled() {\n        return this._cancelled;\n    }\n    canReuseCoinAppConnection(coinAppConnection) {\n        return coinAppConnection.coin === this.coin\n            && coinAppConnection.app === this.requiredApp\n            && Request._isAppVersionSupported(coinAppConnection.appVersion, this.minRequiredAppVersion)\n            && (!this.expectedWalletId || coinAppConnection.walletId === this.expectedWalletId);\n    }\n    cancel() {\n        if (this._cancelled)\n            return;\n        this._cancelled = true;\n        this.fire(Request.EVENT_CANCEL);\n    }\n    on(type, callback) {\n        if (type === Request.EVENT_CANCEL && this._cancelled) {\n            // trigger callback directly\n            callback();\n        }\n        super.on(type, callback);\n    }\n    async checkCoinAppConnection(transport, scrambleKey) {\n        const { name: app, version: appVersion } = await getAppNameAndVersion(transport, scrambleKey);\n        if (app !== this.requiredApp && app !== 'app') { // speculos reports 'app' as app name\n            throw new ErrorState(ErrorType.WRONG_APP, `Wrong app connected: ${app}, required: ${this.requiredApp}`, this);\n        }\n        if (!Request._isAppVersionSupported(appVersion, this.minRequiredAppVersion)) {\n            throw new ErrorState(ErrorType.APP_OUTDATED, `Ledger ${app} app is outdated: ${appVersion}, required: ${this.minRequiredAppVersion}`, this);\n        }\n        return { coin: this.coin, app, appVersion };\n    }\n    get _isWalletIdDerivationRequired() {\n        return !!this.expectedWalletId;\n    }\n    _checkExpectedWalletId(walletId) {\n        if (this.expectedWalletId === undefined || this.expectedWalletId === walletId)\n            return;\n        throw new ErrorState(ErrorType.WRONG_WALLET, 'Wrong wallet or Ledger connected', this);\n    }\n}\nRequest.EVENT_CANCEL = REQUEST_EVENT_CANCEL;\n\nexport { Request as R, getAppNameAndVersion as g };\n//# sourceMappingURL=lazy-chunk-request.es.js.map\n"],"sourceRoot":""}