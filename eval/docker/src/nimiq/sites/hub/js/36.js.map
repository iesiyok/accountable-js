{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-sign-transaction-bitcoin.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AACG;AACyD;AAC9F;;AAEpC,4CAA4C,mEAAc;AAC1D;AACA;AACA,oBAAoB,oEAAkB;AACtC;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAc;AACpD,2CAA2C,sDAAI;AAC/C,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,+CAA+C,eAAe;AACxG;AACA;AACA,oDAAoD,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gFAAgF;AACnG;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA,2EAA2E,OAAO;AAClF;AACA,iDAAiD,wEAAM;AACvD,sEAAsE;AACtE;AACA;AACA;AACA,+CAA+C,wEAAM;AACrD;AACA;AACA,kHAAkH,yDAAO;AACzH;AACA;AACA;AACA,oCAAoC;AACpC,yBAAyB;AACzB,qBAAqB;AACrB,4CAA4C,oEAAkB;AAC9D,iDAAiD,oEAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,4FAA6B,EAAC;AAC7C","file":"js/36.js","sourcesContent":["import { B as Buffer } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { R as RequestBitcoin } from './lazy-chunk-request-bitcoin.es.js';\nimport { RequestTypeBitcoin, parseBip32Path, Coin, ErrorState, ErrorType, Network, AddressTypeBitcoin } from './ledger-api.es.js';\nimport './lazy-chunk-request.es.js';\n\nclass RequestSignTransactionBitcoin extends RequestBitcoin {\n    constructor(transaction, expectedWalletId) {\n        super(expectedWalletId);\n        this.type = RequestTypeBitcoin.SIGN_TRANSACTION;\n        this.transaction = transaction;\n        try {\n            const { inputs, outputs, changePath } = transaction;\n            if (!inputs.length) {\n                throw new Error('No inputs specified');\n            }\n            if (!outputs.length) {\n                throw new Error('No outputs specified');\n            }\n            // verify key paths\n            const keyPaths = [\n                ...inputs.map((input) => input.keyPath),\n                ...(changePath ? [changePath] : []),\n            ];\n            let network = null;\n            let inputType = null;\n            for (const keyPath of keyPaths) {\n                const parsedKeyPath = parseBip32Path(keyPath);\n                if (parsedKeyPath.coin !== Coin.BITCOIN) {\n                    throw new Error(`${keyPath} not a Bitcoin bip32 path following bip44`);\n                }\n                // Note that we don't have to verify the network of outputs. They will be displayed on the ledger screen\n                // depending on whether Bitcoin mainnet or testnet app is used. User will spot differences.\n                if (network && parsedKeyPath.network !== network) {\n                    throw new Error('Not all key paths specify keys on the same network');\n                }\n                network = parsedKeyPath.network;\n                // Note that we don't have to verify the address type of outputs and change; these can be arbitrary.\n                // Inputs must all be of the same type because Ledger's signing of input depends on parameter segwit and\n                // whether bech32 is set as an additional, i.e. all inputs are treated the same and signed according to\n                // these parameters. The transaction could be split and each input be signed separately but that would\n                // be a lot of work.\n                if (keyPath === changePath)\n                    continue; // could still also be an input, but we ignore that corner case\n                if (inputType && parsedKeyPath.addressType !== inputType) {\n                    throw new Error('Must not use mixed input types');\n                }\n                inputType = parsedKeyPath.addressType;\n            }\n            this.network = network;\n            this._inputType = inputType;\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid request: ${e.message || e}`, this);\n        }\n        // Preload Bitcoin lib if needed. Ledger Bitcoin api is already preloaded by parent class. Ignore errors.\n        this._loadBitcoinLibIfNeeded().catch(() => { });\n    }\n    async call(transport) {\n        // Resources:\n        // - to learn more about scripts and how input and output script relate to each other:\n        //   https://en.bitcoin.it/wiki/Script\n        // - to learn more about transactions in general, what they include and their encoding:\n        //   https://en.bitcoin.it/wiki/Transaction\n        // - code for decoding of transactions for a deeper understanding:\n        //   https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts (BitcoinJS)\n        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/splitTransaction.js (parsing into\n        //   Ledger's representation. Code is a bit messy.)\n        // - Ledger's notion of trusted inputs to connect inputs to their amount in a trusted fashion by rehashing the\n        //   input transaction:\n        //   https://bitcoinmagazine.com/articles/how-segregated-witness-is-about-to-fix-hardware-wallets-1478110057\n        //   https://medium.com/segwit-co/segregated-witness-and-hardware-wallets-cc88ba532fb3\n        // - @ledgerhq/hw-app-btc documentation:\n        //   https://github.com/LedgerHQ/ledgerjs/tree/master/packages/hw-app-btc\n        // - @ledgerhq/hw-app-btc transaction building and signing logic:\n        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/createTransaction.js\n        // - Ledger Bitcoin App's api description:\n        //   https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc\n        // - @ledgerhq/hw-app-btc's tests to see an example of correctly sent data:\n        //   https://github.com/LedgerHQ/ledgerjs/tree/master/packages/hw-app-btc/tests\n        // - For decoding transactions:\n        //   https://live.blockcypher.com/btc/decodetx/\n        // - The demo page and code of this lib for demo usage\n        const [api, bitcoinLib] = await Promise.all([\n            // these throw LOADING_DEPENDENCIES_FAILED on failure\n            this._getLowLevelApi(transport),\n            this._loadBitcoinLibIfNeeded(),\n        ]);\n        let parsedTransaction;\n        try {\n            // parse into Ledger's CreateTransactionArg format\n            const { inputs, outputs, changePath, locktime, sigHashType, useTrustedInputForSegwit, } = this.transaction;\n            parsedTransaction = {\n                inputs: inputs.map(({ transaction, index, customScript, sequence }) => [\n                    api.splitTransaction(typeof transaction === 'string' ? transaction : transaction.toHex(), \n                    // Set segwit support always to true because then transactions with and without witnesses are\n                    // correctly parsed (compare bitcoinjs/transaction). Also we can't set it depending on whether\n                    // our own input (transaction's output) is not segwit because it's input might be. Specifically\n                    // fixes parsing legacy inputs which came from segwit inputs.\n                    true),\n                    index,\n                    customScript || null,\n                    sequence || null,\n                ]),\n                associatedKeysets: inputs.map(({ keyPath }) => keyPath),\n                outputScriptHex: typeof outputs === 'string'\n                    ? outputs\n                    : api.serializeTransactionOutputs({\n                        outputs: outputs.map((output) => {\n                            // inspired by how outputs are encoded in __toBuffer in bitcoinjs-lib/transaction.ts\n                            const { amount } = output;\n                            if (Math.floor(amount) !== amount || amount < 0 || amount > 21e9) {\n                                throw new Error(`Invalid Satoshi amount: ${amount}`);\n                            }\n                            const amountBuffer = Buffer.alloc(8);\n                            amountBuffer.writeInt32LE(amount & -1, 0); // eslint-disable-line no-bitwise\n                            amountBuffer.writeUInt32LE(Math.floor(amount / 0x100000000), 4);\n                            let outputScript;\n                            if ('outputScript' in output) {\n                                outputScript = Buffer.from(output.outputScript, 'hex');\n                            }\n                            else {\n                                outputScript = bitcoinLib.address.toOutputScript(output.address, this.network === Network.MAINNET\n                                    ? bitcoinLib.networks.bitcoin\n                                    : bitcoinLib.networks.testnet);\n                            }\n                            return { amount: amountBuffer, script: outputScript };\n                        }),\n                    }).toString('hex'),\n                segwit: this._inputType !== AddressTypeBitcoin.LEGACY,\n                additionals: this._inputType === AddressTypeBitcoin.NATIVE_SEGWIT ? ['bech32'] : [],\n            };\n            // Set optional properties. Note that we did not use ...this.transaction via object spreading above to avoid\n            // setting properties to undefined for which the default values would not be applied anymore in the api call\n            if (changePath !== undefined && changePath !== null) {\n                parsedTransaction.changePath = changePath;\n            }\n            if (locktime !== undefined && locktime !== null) {\n                parsedTransaction.lockTime = locktime;\n            }\n            if (sigHashType !== undefined && sigHashType !== null) {\n                parsedTransaction.sigHashType = sigHashType;\n            }\n            if (useTrustedInputForSegwit !== undefined && useTrustedInputForSegwit !== null) {\n                parsedTransaction.useTrustedInputForSegwit = useTrustedInputForSegwit;\n            }\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, e, this);\n        }\n        // Note: We make api calls outside of the try...catch block to let the exceptions fall through such that\n        // _callLedger can decide how to behave depending on the api error.\n        return api.createPaymentTransactionNew(parsedTransaction);\n    }\n    async _loadBitcoinLibIfNeeded() {\n        // If we need bitcoinjs for address to output script conversion, load it.\n        if (Array.isArray(this.transaction.outputs)\n            && this.transaction.outputs.some((output) => 'address' in output && !!output.address)) {\n            return this._loadBitcoinLib();\n        }\n        return null;\n    }\n}\n\nexport default RequestSignTransactionBitcoin;\n//# sourceMappingURL=lazy-chunk-request-sign-transaction-bitcoin.es.js.map\n"],"sourceRoot":""}