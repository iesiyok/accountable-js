{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-low-level-api.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AAC4B;AAC3B;AAC3C;;AAE5B;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,wEAAM;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,yEAAa;AACrB,QAAQ,yEAAqB;AAC7B;AACA;AACA;AACA;AACA,uCAAuC,yEAAa,IAAI,yEAAqB;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAa;AACrB,QAAQ,yEAAqB;AAC7B,eAAe,YAAY;AAC3B,iDAAiD,wEAAM;AACvD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAa;AACzB,YAAY,yEAAqB;AACjC;AACA;AACA,0BAA0B,wEAAM;AAChC,qBAAqB,wEAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAM;AAClC;AACA;AACA;AACA;AACA,uBAAuB,wEAAM;AAC7B;AACA;AACA;AACA,wBAAwB,wEAAM;AAC9B;AACA;AACA,uBAAuB,wEAAM;AAC7B;AACA;AACA;AACA;AACA,wBAAwB,wEAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,wEAAM;AAChC;AACA;AACA;AACA;AACA;;AAEe,0EAAW,EAAC;AAC3B","file":"js/28-legacy.js","sourcesContent":["import { B as Buffer } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { l as loadNimiqCore, a as loadNimiqCryptography } from './lazy-chunk-request-nimiq.es.js';\nimport { g as getAppNameAndVersion } from './lazy-chunk-request.es.js';\nimport './ledger-api.es.js';\n\nfunction parsePath(path) {\n    if (!path.startsWith('44\\'/242\\'')) {\n        throw new Error(`Not a Nimiq BIP32 path. Path: ${path}. The Nimiq app is authorized only for paths starting with 44'/242'. `\n            + ' Example: 44\\'/242\\'/0\\'/0\\'');\n    }\n    const pathParts = path.split('/').map((part) => {\n        let number = parseInt(part, 10);\n        if (Number.isNaN(number)) {\n            throw new Error(`Invalid path: ${path}`);\n        }\n        if (part.endsWith('\\'')) {\n            number += 0x80000000;\n        }\n        else {\n            throw new Error('Detected a non-hardened path element in requested BIP32 path.'\n                + ' Non-hardended paths are not supported at this time. Please use an all-hardened path.'\n                + ' Example: 44\\'/242\\'/0\\'/0\\'');\n        }\n        return number;\n    });\n    const pathBuffer = Buffer.alloc(1 + pathParts.length * 4);\n    pathBuffer[0] = pathParts.length;\n    pathParts.forEach((element, index) => {\n        pathBuffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return pathBuffer;\n}\nasync function publicKeyToAddress(publicKey) {\n    const [Nimiq] = await Promise.all([\n        loadNimiqCore(),\n        loadNimiqCryptography(),\n    ]);\n    return Nimiq.PublicKey.unserialize(new Nimiq.SerialBuffer(publicKey)).toAddress().toUserFriendlyAddress();\n}\nasync function verifySignature(data, signature, publicKey) {\n    const [Nimiq] = await Promise.all([loadNimiqCore(), loadNimiqCryptography()]);\n    const nimiqSignature = Nimiq.Signature.unserialize(new Nimiq.SerialBuffer(signature));\n    const nimiqPublicKey = Nimiq.PublicKey.unserialize(new Nimiq.SerialBuffer(publicKey));\n    return nimiqSignature.verify(nimiqPublicKey, data);\n}\n\nconst CLA = 0xe0;\nconst INS_GET_PK = 0x02;\nconst INS_SIGN_TX = 0x04;\nconst INS_KEEP_ALIVE = 0x08;\nconst APDU_MAX_SIZE = 150;\nconst P1_FIRST_APDU = 0x00;\nconst P1_MORE_APDU = 0x80;\nconst P1_NO_VALIDATE = 0x00;\nconst P1_VALIDATE = 0x01;\nconst P2_LAST_APDU = 0x00;\nconst P2_MORE_APDU = 0x80;\nconst P2_NO_CONFIRM = 0x00;\nconst P2_CONFIRM = 0x01;\nconst SW_OK = 0x9000;\nconst SW_CANCEL = 0x6985;\nconst SW_KEEP_ALIVE = 0x6e02;\nconst U2F_SCRAMBLE_KEY = 'w0w';\n/**\n * Nimiq API\n *\n * Low level api for communication with the Ledger wallet Nimiq app. This lib is compatible with all @ledgerhq/transport\n * libraries but does on the other hand not include optimizations for specific transport types and returns raw bytes.\n *\n * This library is in nature similar to other hw-app packages in @ledgerhq/ledgerjs and partially based on their code,\n * licenced under the Apache 2.0 licence.\n *\n * @example\n * const nim = new LowLevelApi(transport)\n */\nclass LowLevelApi {\n    constructor(transport) {\n        this._transport = transport;\n        // Note that getAppNameAndVersion does not need to be decorated, as we're decorating it manually. Also note that\n        // the registered methods here do not intersect with the methods of the Bitcoin api, therefore, we can re-use\n        // the same transport instance for both, NIM and BTC apis (as long as a switch between NIM and BTC apps doesn't\n        // cause a disconnect).\n        transport.decorateAppAPIMethods(this, ['getPublicKey', 'signTransaction'], U2F_SCRAMBLE_KEY);\n    }\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * Close the transport instance. Note that this does not emit a disconnect. Disconnects are only emitted when the\n     * device actually disconnects (or switches it's descriptor which happens when switching to the dashboard or apps).\n     */\n    async close() {\n        try {\n            await this._transport.close();\n        }\n        catch (e) {\n            // Ignore. Transport might already be closed.\n        }\n    }\n    /**\n     * @deprecated\n     * Get the version of the connected Ledger Nimiq App. Note that other apps also respond to this call (but for U2F\n     * and WebAuthn only if both apps use the same scramble key).\n     * @returns An object with the version.\n     */\n    async getAppConfiguration() {\n        console.warn('getAppConfiguration is deprecated and will be removed in the future. '\n            + 'Use getAppNameAndVersion instead.');\n        return this.getAppNameAndVersion();\n    }\n    /**\n     * Get the name of the connected app and the app version.\n     * @returns An object with the name and version.\n     * @example\n     * nim.getAppNameAndVersion().then(o => o.version)\n     */\n    async getAppNameAndVersion() {\n        return getAppNameAndVersion(this._transport, U2F_SCRAMBLE_KEY);\n    }\n    /**\n     * Get Nimiq address for a given BIP 32 path.\n     * @param path - A path in BIP 32 format.\n     * @param boolValidate - Optionally enable key pair validation.\n     * @param boolDisplay - Optionally display the address on the ledger.\n     * @returns An object with the address.\n     * @example\n     * nim.getAddress(\"44'/242'/0'/0'\").then(o => o.address)\n     */\n    async getAddress(path, boolValidate = true, boolDisplay = false) {\n        // start loading Nimiq core later needed for transforming public key to address and optional validation\n        loadNimiqCore();\n        loadNimiqCryptography();\n        const { publicKey } = await this.getPublicKey(path, boolValidate, boolDisplay);\n        const address = await publicKeyToAddress(Buffer.from(publicKey));\n        return { address };\n    }\n    /**\n     * Get Nimiq public key for a given BIP 32 path.\n     * @param path - A path in BIP 32 format.\n     * @param boolValidate - Optionally enable key pair validation.\n     * @param boolDisplay - Optionally display the corresponding address on the ledger.\n     * @returns An object with the publicKey.\n     * @example\n     * nim.getPublicKey(\"44'/242'/0'/0'\").then(o => o.publicKey)\n     */\n    async getPublicKey(path, boolValidate = true, boolDisplay = false) {\n        if (boolValidate) {\n            // start loading Nimiq core later needed for validation\n            loadNimiqCore();\n            loadNimiqCryptography();\n        }\n        const pathBuffer = parsePath(path);\n        const verifyMsg = Buffer.from('p=np?', 'ascii');\n        const data = Buffer.concat([pathBuffer, verifyMsg]);\n        let response;\n        response = await this._transport.send(CLA, INS_GET_PK, boolValidate ? P1_VALIDATE : P1_NO_VALIDATE, boolDisplay ? P2_CONFIRM : P2_NO_CONFIRM, data, [SW_OK, SW_KEEP_ALIVE]);\n        // handle heartbeat\n        while (response.slice(response.length - 2).readUInt16BE(0) === SW_KEEP_ALIVE) {\n            // eslint-disable-next-line no-await-in-loop\n            response = await this._transport.send(CLA, INS_KEEP_ALIVE, 0, 0, undefined, [SW_OK, SW_KEEP_ALIVE]);\n        }\n        let offset = 0;\n        const publicKey = response.slice(offset, offset + 32);\n        offset += 32;\n        if (boolValidate) {\n            const signature = response.slice(offset, offset + 64);\n            if (!await verifySignature(verifyMsg, signature, publicKey)) {\n                throw new Error('Bad signature. Keypair is invalid. Please report this.');\n            }\n        }\n        return { publicKey };\n    }\n    /**\n     * Sign a Nimiq transaction.\n     * @param path - A path in BIP 32 format.\n     * @param txContent - Transaction content in serialized form.\n     * @returns An object with the signature.\n     * @example\n     * nim.signTransaction(\"44'/242'/0'/0'\", signatureBase).then(o => o.signature)\n     */\n    async signTransaction(path, txContent) {\n        const pathBuffer = parsePath(path);\n        const transaction = Buffer.from(txContent);\n        const apdus = [];\n        let chunkSize = APDU_MAX_SIZE - pathBuffer.length;\n        if (transaction.length <= chunkSize) {\n            // it fits in a single apdu\n            apdus.push(Buffer.concat([pathBuffer, transaction]));\n        }\n        else {\n            // we need to send multiple apdus to transmit the entire transaction\n            let chunk = Buffer.alloc(chunkSize);\n            let offset = 0;\n            transaction.copy(chunk, 0, offset, chunkSize);\n            apdus.push(Buffer.concat([pathBuffer, chunk]));\n            offset += chunkSize;\n            while (offset < transaction.length) {\n                const remaining = transaction.length - offset;\n                chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;\n                chunk = Buffer.alloc(chunkSize);\n                transaction.copy(chunk, 0, offset, offset + chunkSize);\n                offset += chunkSize;\n                apdus.push(chunk);\n            }\n        }\n        let isHeartbeat = false;\n        let chunkIndex = 0;\n        let status;\n        let response;\n        do {\n            const data = apdus[chunkIndex];\n            // eslint-disable-next-line no-await-in-loop\n            response = await this._transport.send(CLA, isHeartbeat ? INS_KEEP_ALIVE : INS_SIGN_TX, chunkIndex === 0 ? P1_FIRST_APDU : P1_MORE_APDU, // note that for heartbeat p1, p2 and data are ignored\n            chunkIndex === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU, data, [SW_OK, SW_CANCEL, SW_KEEP_ALIVE]);\n            status = response.slice(response.length - 2).readUInt16BE(0);\n            isHeartbeat = status === SW_KEEP_ALIVE;\n            if (!isHeartbeat) {\n                // we can continue sending data or end the loop when all data was sent\n                ++chunkIndex;\n            }\n        } while (isHeartbeat || chunkIndex < apdus.length);\n        if (status !== SW_OK)\n            throw new Error('Transaction approval request was rejected');\n        const signature = Buffer.from(response.slice(0, response.length - 2));\n        return {\n            signature: Uint8Array.from(signature),\n        };\n    }\n}\n\nexport default LowLevelApi;\n//# sourceMappingURL=lazy-chunk-low-level-api.es.js.map\n"],"sourceRoot":""}