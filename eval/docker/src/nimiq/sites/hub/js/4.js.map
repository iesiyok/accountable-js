{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-nimiq.es.js","sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACqB;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa,EAAE,YAAY;AACpD;AACA,KAAK;AACL;AACA,eAAe,QAAQ;AACvB;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,2DAAO;AAClC;AACA;AACA,oBAAoB,sDAAI;AACxB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,eAAe,qCAAqC,0BAA0B,sEAAY,EAAE,OAAO,sDAAI,yBAAyB;AAChI;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0NAAiD,EAAE,wLAAoC,EAAE,wKAA4B,EAAE,qPAA0C;AAC5L;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8DAA8D,eAAe;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8DAA8D,eAAe;AACvH;AACA;AACA;AACA;;AAE6E;AAC7E;;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAuG;;AAEvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD,wDAAwD;AACxD,sBAAsB,4DAAU,CAAC,2DAAS,oCAAoC,IAAI,cAAc,iBAAiB;AACjH;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,yBAAyB,IAAI,oBAAoB,WAAW,cAAc,2BAA2B;AAC/I;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAU,CAAC,2DAAS;AACtC;AACA;AACA,uBAAuB,mDAAoB;;AAEQ;AACnD","file":"js/4.js","sourcesContent":["import { R as Request } from './lazy-chunk-request.es.js';\nimport { Coin, getBip32Path, ErrorState, ErrorType } from './ledger-api.es.js';\n\n// Use jsdelivr instead of nimiq cdn to avoid getting blocked by ad blockers.\nconst coreBasePath = 'https://cdn.jsdelivr.net/npm/@nimiq/core-web/';\nlet nimiqCorePromise = null;\nlet nimiqCryptographyPromise = null;\n/**\n * Lazy-load the Nimiq core api from the cdn server if it's not loaded yet.\n */\nasync function loadNimiqCore(coreVariant = 'web-offline') {\n    // @ts-ignore Return global Nimiq if already loaded.\n    if (window.Nimiq)\n        return window.Nimiq;\n    nimiqCorePromise = nimiqCorePromise || new Promise((resolve, reject) => {\n        const $head = document.getElementsByTagName('head')[0];\n        const $script = document.createElement('script');\n        $script.type = 'text/javascript';\n        $script.onload = () => {\n            $script.parentNode.removeChild($script);\n            resolve();\n        };\n        $script.onerror = (e) => {\n            $script.parentNode.removeChild($script);\n            reject(e);\n        };\n        $script.src = `${coreBasePath}${coreVariant}.js`;\n        $head.appendChild($script);\n    }).then(() => {\n        // @ts-ignore Nimiq is global but to discourage usage as global var we did not declare a global type.\n        const { Nimiq } = window;\n        return Nimiq;\n    }, (e) => {\n        nimiqCorePromise = null;\n        return Promise.reject(e);\n    });\n    return nimiqCorePromise;\n}\n/**\n * Load the WebAssembly and module for cryptographic functions. You will have to do this before calculating hashes,\n * deriving keys or addresses, signing transactions or messages, etc.\n */\nasync function loadNimiqCryptography() {\n    nimiqCryptographyPromise = nimiqCryptographyPromise || (async () => {\n        try {\n            // preload wasm in parallel\n            preloadAsset(`${coreBasePath}worker-wasm.wasm`, 'fetch', true);\n            preloadAsset(`${coreBasePath}worker-wasm.js`, 'script');\n            const Nimiq = await loadNimiqCore();\n            await Nimiq.WasmHelper.doImport();\n        }\n        catch (e) {\n            nimiqCryptographyPromise = null;\n            throw e;\n        }\n    })();\n    return nimiqCryptographyPromise;\n}\nfunction preloadAsset(asset, as, crossOrigin) {\n    const link = document.createElement('link');\n    link.rel = 'preload';\n    link.as = as;\n    link.href = asset;\n    link.onload = link.onerror = () => document.head.removeChild(link); // eslint-disable-line no-multi-assign\n    if (crossOrigin)\n        link.crossOrigin = '';\n    document.head.appendChild(link);\n}\n//# sourceMappingURL=load-nimiq.js.map\n\nclass RequestNimiq extends Request {\n    constructor(expectedWalletId) {\n        super(expectedWalletId);\n        this.coin = Coin.NIMIQ;\n        this.requiredApp = 'Nimiq';\n        this.minRequiredAppVersion = '1.4.2'; // first version supporting web usb\n        // Preload dependencies. Nimiq lib is preloaded individually by request child classes that need it.\n        // Ignore errors.\n        Promise.all([\n            this._loadLowLevelApi(),\n            this._isWalletIdDerivationRequired ? this._loadNimiq() : null,\n        ]).catch(() => { });\n    }\n    async checkCoinAppConnection(transport) {\n        const coinAppConnection = await super.checkCoinAppConnection(transport, 'w0w');\n        if (!this._isWalletIdDerivationRequired)\n            return coinAppConnection; // skip wallet id derivation\n        // Note that api and Nimiq are preloaded in the constructor, therefore we don't need to optimize for load order\n        // or execution order here.\n        const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED on failure\n        // Set validate to false as otherwise the call is much slower. For U2F this can also unfreeze the ledger app,\n        // see transport-comparison.md. However, not sure whether this is still true today and as it's less relevant now\n        // with WebUsb being used by default, we ignore this side effect for !this._isWalletIdDerivationRequired case.\n        const { publicKey: firstAddressPubKeyBytes } = await api.getPublicKey(getBip32Path({ coin: Coin.NIMIQ, addressIndex: 0 }), false, // validate\n        false);\n        const Nimiq = await this._loadNimiq(); // throws LOADING_DEPENDENCIES_FAILED on failure\n        // Compute wallet id. Use sha256 as blake2b yields the nimiq address\n        const walletId = Nimiq.Hash.sha256(firstAddressPubKeyBytes).toBase64();\n        this._checkExpectedWalletId(walletId);\n        coinAppConnection.walletId = walletId;\n        return coinAppConnection;\n    }\n    async _getLowLevelApi(transport) {\n        if (!RequestNimiq._lowLevelApiPromise || transport !== (await RequestNimiq._lowLevelApiPromise).transport) {\n            // no low level api instantiated yet or transport / transport type changed in the meantime\n            RequestNimiq._lowLevelApiPromise = this._loadLowLevelApi()\n                .then((LowLevelApi) => new LowLevelApi(transport), (e) => {\n                RequestNimiq._lowLevelApiPromise = null;\n                return Promise.reject(e);\n            });\n        }\n        return RequestNimiq._lowLevelApiPromise;\n    }\n    async _loadLowLevelApi() {\n        try {\n            // build the low-level-api from source instead of taking it from dist to create optimized chunks and to\n            // avoid double bundling of dependencies like buffer.\n            return (await [import('./lazy-chunk-polyfill-node:buffer.es.js'), import('./lazy-chunk-request.es.js'), import('./ledger-api.es.js'), import('./lazy-chunk-low-level-api.es.js')][3]).default;\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);\n        }\n    }\n    async _loadNimiq() {\n        try {\n            // Note that we don't need to cache a promise as loadNimiqCore and loadNimiqCryptography already do that.\n            const [Nimiq] = await Promise.all([\n                loadNimiqCore(),\n                // needed for wallet id hashing and pub key to address derivation in SignatureProof and BasicTransaction\n                loadNimiqCryptography(),\n            ]);\n            return Nimiq;\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);\n        }\n    }\n}\nRequestNimiq._lowLevelApiPromise = null;\n\nexport { RequestNimiq as R, loadNimiqCryptography as a, loadNimiqCore as l };\n//# sourceMappingURL=lazy-chunk-request-nimiq.es.js.map\n","import { O as Observable, ErrorState, ErrorType, R as REQUEST_EVENT_CANCEL } from './ledger-api.es.js';\n\n// Also see https://github.com/LedgerHQ/ledgerjs/issues/365 for other requests which might be interesting.\nasync function getAppNameAndVersion(transport, scrambleKey) {\n    // Taken from @ledgerhq/hw-app-btc/getAppAndVersion.js. We don't import it directly from there to avoid loading its\n    // unnecessary dependencies. Note that this request is common to all apps and the dashboard and is no Bitcoin app\n    // specific request (it's not on https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc but rather imple-\n    // mented in the Ledger Nano S and Nano X SDKs, see os_io_seproxyhal.c. Also mind the different cla). However, for\n    // u2f and WebAuthn the used scramble key must match the one of the connected app for the Ledger to answer the\n    // request. Therefore, decorate the api method manually to make it compatible with all apps, not only the Nimiq app.\n    const getAppNameAndVersionApi = {\n        async getAppNameAndVersion() {\n            // Note that no u2f heartbeat is required here as the call is not interactive but answers directly.\n            const response = await transport.send(0xb0, 0x01, 0x00, 0x00);\n            const status = response.slice(response.length - 2).readUInt16BE(0);\n            if (status !== 0x9000)\n                throw new Error('getAppNameAndVersion failed'); // should not actually happen\n            let offset = 0;\n            const format = response[offset++];\n            if (format !== 1)\n                throw new Error('Unsupported format');\n            const nameLength = response[offset++];\n            const name = response.slice(offset, (offset += nameLength)).toString('ascii');\n            const versionLength = response[offset++];\n            const version = response.slice(offset, (offset += versionLength)).toString('ascii');\n            return { name, version };\n        },\n    };\n    // Takes care of setting the api lock (for ledger busy errors) and scramble key. Note that decorating the api method\n    // does not modify the transport instance, therefore decorating on each invocation of getAppNameAndVersion does no\n    // harm. Also note that the lock is a property of the transport, thus works correctly across multiple independently\n    // decorated methods.\n    transport.decorateAppAPIMethods(getAppNameAndVersionApi, ['getAppNameAndVersion'], scrambleKey);\n    return getAppNameAndVersionApi.getAppNameAndVersion();\n}\n\nclass Request extends Observable {\n    constructor(expectedWalletId) {\n        super();\n        this._cancelled = false;\n        this.expectedWalletId = expectedWalletId;\n    }\n    static _isAppVersionSupported(versionString, minRequiredVersion) {\n        const version = versionString.split('.').map((part) => parseInt(part, 10));\n        const parsedMinRequiredVersion = minRequiredVersion.split('.').map((part) => parseInt(part, 10));\n        for (let i = 0; i < minRequiredVersion.length; ++i) {\n            if (typeof version[i] === 'undefined' || version[i] < parsedMinRequiredVersion[i])\n                return false;\n            if (version[i] > parsedMinRequiredVersion[i])\n                return true;\n        }\n        return true;\n    }\n    get cancelled() {\n        return this._cancelled;\n    }\n    canReuseCoinAppConnection(coinAppConnection) {\n        return coinAppConnection.coin === this.coin\n            && coinAppConnection.app === this.requiredApp\n            && Request._isAppVersionSupported(coinAppConnection.appVersion, this.minRequiredAppVersion)\n            && (!this.expectedWalletId || coinAppConnection.walletId === this.expectedWalletId);\n    }\n    cancel() {\n        if (this._cancelled)\n            return;\n        this._cancelled = true;\n        this.fire(Request.EVENT_CANCEL);\n    }\n    on(type, callback) {\n        if (type === Request.EVENT_CANCEL && this._cancelled) {\n            // trigger callback directly\n            callback();\n        }\n        super.on(type, callback);\n    }\n    async checkCoinAppConnection(transport, scrambleKey) {\n        const { name: app, version: appVersion } = await getAppNameAndVersion(transport, scrambleKey);\n        if (app !== this.requiredApp && app !== 'app') { // speculos reports 'app' as app name\n            throw new ErrorState(ErrorType.WRONG_APP, `Wrong app connected: ${app}, required: ${this.requiredApp}`, this);\n        }\n        if (!Request._isAppVersionSupported(appVersion, this.minRequiredAppVersion)) {\n            throw new ErrorState(ErrorType.APP_OUTDATED, `Ledger ${app} app is outdated: ${appVersion}, required: ${this.minRequiredAppVersion}`, this);\n        }\n        return { coin: this.coin, app, appVersion };\n    }\n    get _isWalletIdDerivationRequired() {\n        return !!this.expectedWalletId;\n    }\n    _checkExpectedWalletId(walletId) {\n        if (this.expectedWalletId === undefined || this.expectedWalletId === walletId)\n            return;\n        throw new ErrorState(ErrorType.WRONG_WALLET, 'Wrong wallet or Ledger connected', this);\n    }\n}\nRequest.EVENT_CANCEL = REQUEST_EVENT_CANCEL;\n\nexport { Request as R, getAppNameAndVersion as g };\n//# sourceMappingURL=lazy-chunk-request.es.js.map\n"],"sourceRoot":""}