{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-sign-message-bitcoin.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AACG;AACyD;AAC9F;;AAEpC,wCAAwC,mEAAc;AACtD;AACA;AACA,oBAAoB,oEAAkB;AACtC;AACA;AACA;AACA,kCAAkC,wEAAc;AAChD,uCAAuC,sDAAI;AAC3C;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8CAA8C,QAAQ,IAAI,eAAe;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,kBAAkB,wEAAM;AACxB,kBAAkB,wEAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS;AAC1C;AACA,6BAA6B,yDAAO,kCAAkC,oEAAkB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAkB;AAC/B,aAAa,oEAAkB;AAC/B,aAAa,oEAAkB;AAC/B,SAAS;AACT,eAAe,gCAAgC,+CAA+C,wBAAwB;AACtH,eAAe;AACf;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa,oEAAkB;AAC/B,aAAa,oEAAkB;AAC/B,aAAa,oEAAkB;AAC/B,SAAS;AACT;AACA,0BAA0B,wEAAM,SAAS,OAAO,EAAE,EAAE,EAAE,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEe,wFAAyB,EAAC;AACzC","file":"js/35-legacy.js","sourcesContent":["import { B as Buffer } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { R as RequestBitcoin } from './lazy-chunk-request-bitcoin.es.js';\nimport { RequestTypeBitcoin, parseBip32Path, Coin, ErrorState, ErrorType, Network, AddressTypeBitcoin } from './ledger-api.es.js';\nimport './lazy-chunk-request.es.js';\n\nclass RequestSignMessageBitcoin extends RequestBitcoin {\n    constructor(keyPath, message, expectedWalletId) {\n        super(expectedWalletId);\n        this.type = RequestTypeBitcoin.SIGN_MESSAGE;\n        this.keyPath = keyPath;\n        this.message = message;\n        try {\n            const parsedKeyPath = parseBip32Path(keyPath);\n            if (parsedKeyPath.coin !== Coin.BITCOIN)\n                throw new Error('Not a Bitcoin bip32 path following bip44');\n            this.network = parsedKeyPath.network;\n            this._addressType = parsedKeyPath.addressType;\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}: ${e.message || e}`, this);\n        }\n    }\n    async call(transport) {\n        // Resources:\n        // - Message signature specification (bip137):\n        //   https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki\n        //   Note that the message signatures generated by the Ledger are not based on the newer bip322 yet.\n        // - Description of v, r, s values the signature consists of:\n        //   https://bitcoin.stackexchange.com/a/38909\n        // - Ledger Bitcoin App's api description:\n        //   https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc#sign-message\n        // - The implementation of the api call in @ledgerhq/hw-app-btc:\n        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/signMessage.js\n        //   Also handles the conversion of the ASN-1 encoded signature created by the Ledger (defined in\n        //   https://www.secg.org/sec1-v2.pdf) to BitcoinQT format. However note that the returned v value does not\n        //   contain the address type constant yet. For converting this result to the final concatenated base64\n        //   signature including the address type see here:\n        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/Btc.js#L92\n        // - For confirming signed messages online:\n        //   https://www.verifybitcoinmessage.com/\n        // - bitcoinjs-message library for client side signing and verification of message signatures:\n        //   https://github.com/bitcoinjs/bitcoinjs-message\n        const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED on failure\n        let messageBuffer;\n        try {\n            messageBuffer = typeof this.message === 'string'\n                ? Buffer.from(this.message, 'utf8') // throws if invalid utf8\n                : Buffer.from(this.message);\n            if (messageBuffer.length >= 2 ** 16) {\n                // the message length is encoded in two bytes and is 0 terminated.\n                throw new Error('Message too long');\n            }\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, e, this);\n        }\n        if (this.network === Network.TESTNET && this._addressType === AddressTypeBitcoin.LEGACY) {\n            console.warn('Ledgers seem to generate invalid signatures for testnet legacy p2pkh addresses. '\n                + 'Prefer using nested p2sh segwit or native bech32 segwit addresses.');\n        }\n        // Note: We make api calls outside of the try...catch block to let the exceptions fall through such that\n        // _callLedger can decide how to behave depending on the api error.\n        const addressFormat = {\n            [AddressTypeBitcoin.LEGACY]: 'legacy',\n            [AddressTypeBitcoin.P2SH_SEGWIT]: 'p2sh',\n            [AddressTypeBitcoin.NATIVE_SEGWIT]: 'bech32',\n        }[this._addressType];\n        const { bitcoinAddress: signerAddress } = await api.getWalletPublicKey(this.keyPath, { format: addressFormat });\n        const { v, // recId (not including the address type constant)\n        r, // r of ECDSA signature\n        s, } = await api.signMessageNew(this.keyPath, messageBuffer.toString('hex'));\n        // Create the signature header, see\n        // https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki#procedure-for-signingverifying-a-signature\n        const headerAddressTypeConstant = {\n            [AddressTypeBitcoin.LEGACY]: 31,\n            [AddressTypeBitcoin.P2SH_SEGWIT]: 35,\n            [AddressTypeBitcoin.NATIVE_SEGWIT]: 39,\n        }[this._addressType];\n        const header = (v + headerAddressTypeConstant).toString(16);\n        const signature = Buffer.from(`${header}${r}${s}`, 'hex').toString('base64');\n        return {\n            signerAddress,\n            signature,\n        };\n    }\n}\n\nexport default RequestSignMessageBitcoin;\n//# sourceMappingURL=lazy-chunk-request-sign-message-bitcoin.es.js.map\n"],"sourceRoot":""}