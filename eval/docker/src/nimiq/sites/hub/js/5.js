(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[5],{

/***/ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-bitcoin.es.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-bitcoin.es.js ***!
  \*********************************************************************************************/
/*! exports provided: R */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return RequestBitcoin; });
/* harmony import */ var _lazy_chunk_request_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazy-chunk-request.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js");
/* harmony import */ var _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ledger-api.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/ledger-api.es.js");



class RequestBitcoin extends _lazy_chunk_request_es_js__WEBPACK_IMPORTED_MODULE_0__["R"] {
    constructor(expectedWalletId) {
        super(expectedWalletId);
        this.coin = _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["Coin"].BITCOIN;
        this.minRequiredAppVersion = '1.3.8'; // first version supporting web usb
        // Preload dependencies. Bitcoin lib is preloaded individually by request child classes that need it.
        // Ignore errors.
        Promise.all([
            this._loadLowLevelApi(),
            this._isWalletIdDerivationRequired ? [__webpack_require__.e(/*! import() */ 7).then(__webpack_require__.bind(null, /*! ./lazy-chunk-_commonjsHelpers.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-_commonjsHelpers.es.js")), __webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./lazy-chunk-polyfill-node:buffer.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:buffer.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(10)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-sha256.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-sha256.es.js"))][2].then(function (n) { return n.s; }) : null,
        ]).catch(() => { });
    }
    get requiredApp() {
        // Note that Ledger provides a separate Bitcoin testnet app which can be installed by enabling developer mode in
        // Ledger Live. Operating on testnet paths is generally allowed also for the Bitcoin mainnet app and retrieved
        // public keys (and thus also computed extended keys) and signed transactions are identical to the testnet app,
        // however addresses displayed or generated by the Ledger are in mainnet format, regardless of whether a testnet
        // path is specified. The testnet app since version 1.4.6 shows a warning when accessing mainnet paths. For
        // these reason we generally block using the Bitcoin mainnet and testnet apps interchangeably.
        return `Bitcoin${this.network === _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["Network"].TESTNET ? ' Test' : ''}`;
    }
    async checkCoinAppConnection(transport) {
        const coinAppConnection = await super.checkCoinAppConnection(transport, 'BTC');
        if (!this._isWalletIdDerivationRequired)
            return coinAppConnection; // skip wallet id derivation
        // Note that api and sha256 are preloaded in the constructor, therefore we don't need to optimize for load order
        // or execution order here.
        const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED on failure
        // TODO For u2f and WebAuthn, the Ledger displays a confirmation screen to get the public key if the user has
        //  this privacy setting enabled. The get public key functionality also supports setting a permission token
        //  which however is not implemented in @ledgerhq/hw-app-btc and therefore would need to be implemented manually
        const { publicKey } = await api.getWalletPublicKey(Object(_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["getBip32Path"])({
            coin: _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["Coin"].BITCOIN,
            addressType: _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["AddressTypeBitcoin"].LEGACY,
            network: this.network,
            accountIndex: 0,
            addressIndex: 0,
            isInternal: false,
        }));
        let Sha256;
        try {
            // Note that loading sha here only for wallet id calculation is not really wasteful as it's also imported
            // by the ledger api and bitcoinjs.
            Sha256 = (await [__webpack_require__.e(/*! import() */ 7).then(__webpack_require__.bind(null, /*! ./lazy-chunk-_commonjsHelpers.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-_commonjsHelpers.es.js")), __webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./lazy-chunk-polyfill-node:buffer.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:buffer.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(10)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-sha256.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-sha256.es.js"))][2].then(function (n) { return n.s; })).default;
        }
        catch (e) {
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["ErrorType"].LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);
        }
        const walletId = new Sha256().update(publicKey, 'hex').digest('base64');
        this._checkExpectedWalletId(walletId);
        coinAppConnection.walletId = walletId;
        return coinAppConnection;
    }
    async _getLowLevelApi(transport) {
        if (!RequestBitcoin._lowLevelApiPromise
            || transport !== (await RequestBitcoin._lowLevelApiPromise).transport) {
            // No low level api instantiated yet or transport / transport type changed in the meantime.
            // Note that property transport exists on AppBtc but is not defined in the types. Unfortunately we can't
            // use type augmentation as it's the default export and therefore we cast to any.
            RequestBitcoin._lowLevelApiPromise = this._loadLowLevelApi()
                .then((LowLevelApi) => new LowLevelApi(transport), (e) => {
                RequestBitcoin._lowLevelApiPromise = null;
                return Promise.reject(e);
            });
        }
        return RequestBitcoin._lowLevelApiPromise;
    }
    async _loadLowLevelApi() {
        try {
            return (await [__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./lazy-chunk-polyfill-node:buffer.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:buffer.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(2)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-index.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-index.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(9)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-polyfill-node:process.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:process.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(8), __webpack_require__.e(14)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-index.es4.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-index.es4.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(3)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-index.es3.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-index.es3.js")), __webpack_require__.e(/*! import() */ 1).then(__webpack_require__.bind(null, /*! ./lazy-chunk-events.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-events.es.js")), __webpack_require__.e(/*! import() */ 7).then(__webpack_require__.bind(null, /*! ./lazy-chunk-_commonjsHelpers.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-_commonjsHelpers.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(10)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-sha256.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-sha256.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(3), __webpack_require__.e(8), __webpack_require__.e(26)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-Btc.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-Btc.es.js"))][8]).default;
        }
        catch (e) {
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["ErrorType"].LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);
        }
    }
    async _loadBitcoinLib() {
        try {
            return await [__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./lazy-chunk-polyfill-node:buffer.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:buffer.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(10)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-sha256.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-sha256.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(8), __webpack_require__.e(14)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-index.es4.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-index.es4.js")), __webpack_require__.e(/*! import() */ 7).then(__webpack_require__.bind(null, /*! ./lazy-chunk-_commonjsHelpers.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-_commonjsHelpers.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(9)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-polyfill-node:process.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:process.es.js")), __webpack_require__.e(/*! import() */ 1).then(__webpack_require__.bind(null, /*! ./lazy-chunk-events.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-events.es.js")), Promise.all(/*! import() */[__webpack_require__.e(0), __webpack_require__.e(1), __webpack_require__.e(8), __webpack_require__.e(13)]).then(__webpack_require__.bind(null, /*! ./lazy-chunk-bitcoin-lib.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-bitcoin-lib.es.js"))][6];
        }
        catch (e) {
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_1__["ErrorType"].LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);
        }
    }
}
RequestBitcoin._lowLevelApiPromise = null;


//# sourceMappingURL=lazy-chunk-request-bitcoin.es.js.map


/***/ }),

/***/ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js ***!
  \*************************************************************************************/
/*! exports provided: R, g */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getAppNameAndVersion; });
/* harmony import */ var _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ledger-api.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/ledger-api.es.js");


// Also see https://github.com/LedgerHQ/ledgerjs/issues/365 for other requests which might be interesting.
async function getAppNameAndVersion(transport, scrambleKey) {
    // Taken from @ledgerhq/hw-app-btc/getAppAndVersion.js. We don't import it directly from there to avoid loading its
    // unnecessary dependencies. Note that this request is common to all apps and the dashboard and is no Bitcoin app
    // specific request (it's not on https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc but rather imple-
    // mented in the Ledger Nano S and Nano X SDKs, see os_io_seproxyhal.c. Also mind the different cla). However, for
    // u2f and WebAuthn the used scramble key must match the one of the connected app for the Ledger to answer the
    // request. Therefore, decorate the api method manually to make it compatible with all apps, not only the Nimiq app.
    const getAppNameAndVersionApi = {
        async getAppNameAndVersion() {
            // Note that no u2f heartbeat is required here as the call is not interactive but answers directly.
            const response = await transport.send(0xb0, 0x01, 0x00, 0x00);
            const status = response.slice(response.length - 2).readUInt16BE(0);
            if (status !== 0x9000)
                throw new Error('getAppNameAndVersion failed'); // should not actually happen
            let offset = 0;
            const format = response[offset++];
            if (format !== 1)
                throw new Error('Unsupported format');
            const nameLength = response[offset++];
            const name = response.slice(offset, (offset += nameLength)).toString('ascii');
            const versionLength = response[offset++];
            const version = response.slice(offset, (offset += versionLength)).toString('ascii');
            return { name, version };
        },
    };
    // Takes care of setting the api lock (for ledger busy errors) and scramble key. Note that decorating the api method
    // does not modify the transport instance, therefore decorating on each invocation of getAppNameAndVersion does no
    // harm. Also note that the lock is a property of the transport, thus works correctly across multiple independently
    // decorated methods.
    transport.decorateAppAPIMethods(getAppNameAndVersionApi, ['getAppNameAndVersion'], scrambleKey);
    return getAppNameAndVersionApi.getAppNameAndVersion();
}

class Request extends _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["O"] {
    constructor(expectedWalletId) {
        super();
        this._cancelled = false;
        this.expectedWalletId = expectedWalletId;
    }
    static _isAppVersionSupported(versionString, minRequiredVersion) {
        const version = versionString.split('.').map((part) => parseInt(part, 10));
        const parsedMinRequiredVersion = minRequiredVersion.split('.').map((part) => parseInt(part, 10));
        for (let i = 0; i < minRequiredVersion.length; ++i) {
            if (typeof version[i] === 'undefined' || version[i] < parsedMinRequiredVersion[i])
                return false;
            if (version[i] > parsedMinRequiredVersion[i])
                return true;
        }
        return true;
    }
    get cancelled() {
        return this._cancelled;
    }
    canReuseCoinAppConnection(coinAppConnection) {
        return coinAppConnection.coin === this.coin
            && coinAppConnection.app === this.requiredApp
            && Request._isAppVersionSupported(coinAppConnection.appVersion, this.minRequiredAppVersion)
            && (!this.expectedWalletId || coinAppConnection.walletId === this.expectedWalletId);
    }
    cancel() {
        if (this._cancelled)
            return;
        this._cancelled = true;
        this.fire(Request.EVENT_CANCEL);
    }
    on(type, callback) {
        if (type === Request.EVENT_CANCEL && this._cancelled) {
            // trigger callback directly
            callback();
        }
        super.on(type, callback);
    }
    async checkCoinAppConnection(transport, scrambleKey) {
        const { name: app, version: appVersion } = await getAppNameAndVersion(transport, scrambleKey);
        if (app !== this.requiredApp && app !== 'app') { // speculos reports 'app' as app name
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["ErrorType"].WRONG_APP, `Wrong app connected: ${app}, required: ${this.requiredApp}`, this);
        }
        if (!Request._isAppVersionSupported(appVersion, this.minRequiredAppVersion)) {
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["ErrorType"].APP_OUTDATED, `Ledger ${app} app is outdated: ${appVersion}, required: ${this.minRequiredAppVersion}`, this);
        }
        return { coin: this.coin, app, appVersion };
    }
    get _isWalletIdDerivationRequired() {
        return !!this.expectedWalletId;
    }
    _checkExpectedWalletId(walletId) {
        if (this.expectedWalletId === undefined || this.expectedWalletId === walletId)
            return;
        throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["ErrorType"].WRONG_WALLET, 'Wrong wallet or Ledger connected', this);
    }
}
Request.EVENT_CANCEL = _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_0__["R"];


//# sourceMappingURL=lazy-chunk-request.es.js.map


/***/ })

}]);
//# sourceMappingURL=5.js.map