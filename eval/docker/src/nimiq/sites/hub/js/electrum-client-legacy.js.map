{"version":3,"sources":["sources://./node_modules/@nimiq/electrum-client/dist/electrum-api/ElectrumApi.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-api/helpers.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-api/index.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-api/types.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-client/Agent.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-client/ElectrumClient.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-client/GenesisConfig.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-client/Stores.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-client/index.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-client/types.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-ws/ElectrumWS.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-ws/Observable.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-ws/helpers.js","sources://./node_modules/@nimiq/electrum-client/dist/electrum-ws/index.js","sources://./node_modules/@nimiq/electrum-client/dist/index.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACiD;AACxB;AAC7D;AACP,4BAA4B;AAC5B;AACA,qCAAqC,sDAAkB;AACvD;AACA;AACA,8BAA8B,sDAAkB;AAChD;AACA;AACA;AACA,wCAAwC,sDAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAU;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAe,kDAAkD,EAAE;AAChG,6BAA6B,kEAAe,iGAAiG,EAAE;AAC/I,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa,KAAK;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA,kFAAkF,KAAK,IAAI,kBAAkB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAU;AAC7B;AACA,6BAA6B,qEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAU;AACzB;AACA;AACA;AACA,eAAe,mEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,mEAAkB;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sDAAkB;AAClF,yCAAyC,sDAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sDAAkB;AAClF,yCAAyC,sDAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sDAAkB;AAClF,yCAAyC,sDAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAiB;AAC9C;AACA,eAAe,qEAAU;AACzB;AACA;;;;;;;;;;;;;AC7NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACX;AACwB;AACjD;AACP;AACA,iBAAiB,mDAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+DAAU;AAC9C,wCAAwC,+DAAU;AAClD;AACA;AACO;AACP;AACA,aAAa,yDAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAU;AAC1B,yBAAyB,+DAAU;AACnC;AACA;AACA;AACA;AACA,mBAAmB,+DAAU;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,qDAAiB;AACnC;AACA;AACA;AACA;AACA,gBAAgB,+DAAU;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,yDAAqB;AAC7B;AACA,oBAAoB,oDAAgB;AACpC;AACA;AACA,eAAe,sDAAkB;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,sDAAkB;AACjC,oBAAoB,sDAAkB;AACtC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,sDAAkB;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,oDAAgB;AAC7C;AACA;AACA;AACA;AACA,sDAAsD,oDAAgB;AACtE;AACA;AACA,mBAAmB,sDAAkB;AACrC,wBAAwB,sDAAkB;AAC1C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,gCAAgC,oDAAgB;AAChD,mBAAmB,sDAAkB;AACrC;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,oDAAgB;AAC7C;AACA;AACA;AACA;AACA,sDAAsD,oDAAgB;AACtE;AACA,4BAA4B,oDAAgB;AAC5C;AACA,mBAAmB,sDAAkB;AACrC,wBAAwB,sDAAkB;AAC1C,4BAA4B,sDAAkB;AAC9C;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,mBAAmB,sDAAkB;AACrC,wBAAwB,sDAAkB;AAC1C,4BAA4B,sDAAkB;AAC9C;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,6BAA6B,oDAAgB;AAC7C;AACA;AACA;AACA;AACA,sDAAsD,oDAAgB;AACtE;AACA;AACA,mBAAmB,sDAAkB;AACrC,wBAAwB,sDAAkB;AAC1C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,gCAAgC,oDAAgB;AAChD,mBAAmB,sDAAkB;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB,yDAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,oDAAM,MAAM,+DAAU;AACpC;AACA,gBAAgB,oDAAM,MAAM,+DAAU;AACtC;AACA,0FAA0F,oDAAM,MAAM,+DAAU;AAChH;AACA;AACO;AACP;AACA,gBAAgB,oDAAM,MAAM,+DAAU;AACtC;AACA;AACA;;;;;;;;;;;;;AC5MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;AACE;AACI;;;;;;;;;;;;;ACF9B;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;ACL/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACH;AACL;AACO;AACD;AACyB;AACjF;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACO,oBAAoB,kEAAU;AACrC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6DAAS;AACpE,wDAAwD,UAAU,GAAG,eAAe,GAAG,mBAAmB;AAC1G,6BAA6B,6DAAS;AACtC,kCAAkC,qEAAW;AAC7C,yBAAyB,4DAAa;AACtC,mCAAmC,UAAU,GAAG,eAAe,GAAG,mBAAmB;AACrF;AACA,aAAa;AACb;AACA,4FAA4F,6DAAS;AACrG,wDAAwD,UAAU,GAAG,eAAe;AACpF,6BAA6B,6DAAS;AACtC,kCAAkC,qEAAW;AAC7C,yBAAyB,4DAAa;AACtC;AACA;AACA,0BAA0B,0BAA0B,4DAAa,eAAe,GAAG,UAAU;AAC7F,aAAa;AACb;AACA,4FAA4F,6DAAS;AACrG,wDAAwD,UAAU,GAAG,eAAe;AACpF,6BAA6B,6DAAS;AACtC,kCAAkC,qEAAW;AAC7C,yBAAyB,4DAAa;AACtC;AACA;AACA,0BAA0B,0BAA0B,4DAAa,eAAe,GAAG,UAAU;AAC7F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kDAAW,CAAC,GAAG,qDAAc,CAAC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4DAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAU;AAClC;AACA;AACA,YAAY,kDAAU;AACtB;AACA;AACA,YAAY,kDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAU;AAClC;AACA;AACA,oBAAoB,kDAAU;AAC9B;AACA;AACA,sCAAsC,wDAAgB;AACtD;AACA;AACA;AACA,mCAAmC,wDAAgB,2CAA2C,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qBAAqB,sDAAO;AAC5B;AACA,qBAAqB,sDAAO;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,6DAAS;AAC1B,iBAAiB,6DAAS;AAC1B,iBAAiB,6DAAS;AAC1B;AACA;AACA;;;;;;;;;;;;;AC1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuD;AACL;AACG;AACO;AACJ;AACC;AAClD;AACP,4BAA4B;AAC5B,8BAA8B,qDAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO,QAAQ,gBAAgB;AACrG;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ,QAAQ,gBAAgB;AAClG;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA,sCAAsC,wDAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK,QAAQ,gBAAgB;AAC/F;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ,QAAQ,gBAAgB;AAC/G;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA,iGAAiG,uDAAgB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAgB;AAChD;AACA;AACA;AACA,4CAA4C,uDAAgB,aAAa,uDAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA,0CAA0C,uDAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAgB,0BAA0B,uDAAgB;AAC7F;AACA,oDAAoD,0EAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,gBAAgB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAc;AAClD;AACA;AACA;AACA;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qDAAc;AACtD;AACA;AACA;AACA;AACA,kCAAkC,qDAAc;AAChD;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,gCAAgC,qDAAc;AAC9C;AACA;AACA;AACA,iCAAiC,6DAAS,MAAM,6DAAS,MAAM,6DAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4CAAK;AAC/B,iBAAiB,4CAAU,wCAAwC,qDAAc;AACjF,iBAAiB,4CAAU;AAC3B;AACA,oCAAoC,qDAAc;AAClD,SAAS;AACT,iBAAiB,4CAAU;AAC3B,iBAAiB,4CAAU;AAC3B,iBAAiB,4CAAU;AAC3B,iBAAiB,4CAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4DAAa,kBAAkB,sDAAO;AAC5F;AACA,sDAAsD,4DAAa,kBAAkB,sDAAO;AAC5F;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAS;AAC1B;AACA,2CAA2C,6DAAS;AACpD;AACA;AACA;AACA,iBAAiB,6DAAS;AAC1B;AACA,2CAA2C,6DAAS;AACpD;AACA;AACA;AACA,iBAAiB,6DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAU;AACnC,yBAAyB,4CAAU;AACnC,yBAAyB,4CAAU;AACnC,yBAAyB,4CAAU;AACnC,yBAAyB,4CAAU;AACnC,yBAAyB,4CAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAgB;AACnC;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAgB;AACpC;AACA;AACA;AACA,+EAA+E,uDAAgB,aAAa,uDAAgB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,yCAAyC,uDAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAgB;AACnC;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;;;;;;;;;;;;;ACzgBA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACpC;AACP;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mDAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAA4C,oCAAoC,uBAAuB;AACpH,aAAa,wCAAwC,oCAAoC,uBAAuB;AAChH,aAAa,wCAAwC,oCAAoC,uBAAuB;AAChH,aAAa,yCAAyC,oCAAoC,uBAAuB;AACjH,aAAa,0CAA0C,mCAAmC,uBAAuB;AACjH,aAAa,oCAAoC,mCAAmC,uBAAuB;AAC3G,aAAa,6CAA6C,oCAAoC,uBAAuB;AACrH,aAAa,0CAA0C,oCAAoC,uBAAuB;AAClH,aAAa,0CAA0C,mCAAmC,uBAAuB;AACjH,aAAa,2CAA2C,mCAAmC,uBAAuB;AAClH,aAAa,sCAAsC,oCAAoC,uBAAuB;AAC9G,aAAa,wCAAwC,oCAAoC,uBAAuB;AAChH,aAAa,uCAAuC,oCAAoC,uBAAuB;AAC/G,aAAa,gCAAgC,mCAAmC,uBAAuB;AACvG,aAAa,2CAA2C,oCAAoC,uBAAuB;AACnH,aAAa,6CAA6C,oCAAoC,uBAAuB;AACrH,aAAa,8BAA8B,mCAAmC,uBAAuB;AACrG,aAAa,wCAAwC,oCAAoC,uBAAuB;AAChH,aAAa,2BAA2B,mCAAmC,uBAAuB;AAClG,aAAa,0CAA0C,oCAAoC,uBAAuB;AAClH,aAAa,mDAAmD,oCAAoC,uBAAuB;AAC3H,aAAa,sCAAsC,mCAAmC,uBAAuB;AAC7G,aAAa,qCAAqC,oCAAoC,uBAAuB;AAC7G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,4CAA4C,oCAAoC,uBAAuB;AACpH;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAO;AACA;;;;;;;;;;;;;ACDP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;AACA;AACC;AACO;AACC;;;;;;;;;;;;;ACJjC;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;;;;;;;;;;;;;ACb7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACe;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACA;AACP;AACA;AACA;AACA;AACO,yBAAyB,sDAAU;AAC1C,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE,gDAAgD,iBAAiB;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,0CAA0C,8DAAa;AACvD;AACA;AACA;AACA,mCAAmC,OAAO,EAAE,oCAAoC,UAAU,OAAO;AACjG;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA,mCAAmC,OAAO,EAAE,oCAAoC,UAAU,OAAO;AACjG;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI,SAAS,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,8DAA8D,8DAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO,EAAE,oCAAoC,UAAU,OAAO;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB,EAAE,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpMA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,wCAAwC,EAAE;AAC1C;AACO;AACP;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACG;;;;;;;;;;;;;ACD7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACC;AACG","file":"js/electrum-client-legacy.js","sourcesContent":["import * as BitcoinJS from 'bitcoinjs-lib';\nimport { ElectrumWS, ElectrumWSEvent, bytesToHex, hexToBytes, } from '../electrum-ws/index';\nimport { transactionToPlain, blockHeaderToPlain, } from './helpers';\nexport class ElectrumApi {\n    constructor(options = {}) {\n        if (typeof options.network === 'string') {\n            if (!(options.network in BitcoinJS.networks)) {\n                throw new Error('Invalid network name');\n            }\n            options.network = BitcoinJS.networks[options.network];\n        }\n        this.options = {\n            ...options,\n            network: options.network || BitcoinJS.networks.bitcoin,\n        };\n        const wsOptions = {};\n        if ('proxy' in this.options)\n            wsOptions.proxy = this.options.proxy;\n        if ('token' in this.options)\n            wsOptions.token = this.options.token;\n        if ('reconnect' in this.options)\n            wsOptions.reconnect = this.options.reconnect;\n        this.socket = new ElectrumWS(this.options.endpoint, wsOptions);\n    }\n    async waitForConnectionEstablished() {\n        if (this.socket.isConnected())\n            return true;\n        return new Promise((resolve, reject) => {\n            this.socket.once(ElectrumWSEvent.CONNECTED, () => (resolve(true), reject = () => { }));\n            this.socket.once(ElectrumWSEvent.CLOSE, () => (reject(new Error('Unable to establish a WebSocket connection')), resolve = () => { }));\n        });\n    }\n    async getBalance(address) {\n        return this.socket.request('blockchain.scripthash.get_balance', await this.addressToScriptHash(address));\n    }\n    async getReceipts(addressOrScriptHash) {\n        const receipts = await this.socket.request('blockchain.scripthash.get_history', addressOrScriptHash.length === 64\n            ? addressOrScriptHash\n            : await this.addressToScriptHash(addressOrScriptHash));\n        receipts.sort((a, b) => (Math.max(0, b.height) || Number.MAX_SAFE_INTEGER) - (Math.max(0, a.height) || Number.MAX_SAFE_INTEGER));\n        return receipts.map((r) => ({\n            blockHeight: r.height,\n            transactionHash: r.tx_hash,\n            ...(r.fee ? { fee: r.fee } : {}),\n        }));\n    }\n    async getTransaction(hash, block) {\n        if (block)\n            await this.proofTransaction(hash, block);\n        const raw = await this.socket.request('blockchain.transaction.get', hash);\n        return transactionToPlain(raw, this.options.network);\n    }\n    async proofTransaction(hash, block) {\n        const transactionMerkleRoot = await this.getTransactionMerkleRoot(hash, block.blockHeight);\n        if (transactionMerkleRoot !== block.merkleRoot) {\n            throw new Error(`Invalid transaction merkle proof for block height: ${hash}, ${block.blockHeight}`);\n        }\n        return true;\n    }\n    async getTransactionMerkleRoot(hash, height) {\n        const proof = await this.socket.request('blockchain.transaction.get_merkle', hash, height);\n        if (proof.block_height !== height) {\n            throw new Error('Invalid reference block height received in transaction merkle proof');\n        }\n        let i = proof.pos;\n        let node = hexToBytes(hash).reverse();\n        for (const pairHash of proof.merkle) {\n            const pairNode = hexToBytes(pairHash).reverse();\n            const concatenated = new Uint8Array(i % 2 === 0\n                ? [...node, ...pairNode]\n                : [...pairNode, ...node]);\n            node = new Uint8Array(await crypto.subtle.digest('SHA-256', await crypto.subtle.digest('SHA-256', concatenated)));\n            i = Math.floor(i / 2);\n        }\n        return bytesToHex(node.reverse());\n    }\n    async getBlockHeader(height) {\n        const raw = await this.socket.request('blockchain.block.header', height);\n        return blockHeaderToPlain(raw, height);\n    }\n    async estimateFee(targetBlocks) {\n        const coinsPerKilobyte = await this.socket.request('blockchain.estimatefee', targetBlocks);\n        return Math.round(coinsPerKilobyte / 1000 * 1e8);\n    }\n    async getFeeHistogram() {\n        return this.socket.request('mempool.get_fee_histogram');\n    }\n    async getRelayFee() {\n        const coins = await this.socket.request('blockchain.relayfee');\n        return Math.round(coins * 1e8);\n    }\n    async broadcastTransaction(rawTx) {\n        const tx = transactionToPlain(rawTx, this.options.network);\n        let hash;\n        try {\n            hash = await this.socket.request('blockchain.transaction.broadcast', rawTx);\n        }\n        catch (error) {\n            if (error.message.includes('Transaction already in block chain')) {\n                tx.onChain = true;\n                return tx;\n            }\n            else\n                throw error;\n        }\n        if (hash === tx.transactionHash)\n            return tx;\n        else\n            throw new Error(hash);\n    }\n    async subscribeReceipts(address, callback) {\n        return this.socket.subscribe('blockchain.scripthash', async (scriptHash, status) => {\n            callback(!status ? [] : await this.getReceipts(scriptHash));\n        }, await this.addressToScriptHash(address));\n    }\n    async subscribeHeaders(callback) {\n        return this.socket.subscribe('blockchain.headers', (headerInfo) => {\n            callback(blockHeaderToPlain(headerInfo.hex, headerInfo.height));\n        });\n    }\n    async setProtocolVersion(clientName, protocolVersion) {\n        return this.socket.request('server.version', clientName, protocolVersion);\n    }\n    async getFeatures() {\n        return this.socket.request('server.features');\n    }\n    async getPeers() {\n        const peers = await this.socket.request('server.peers.subscribe');\n        return peers.map(peer => {\n            const ip = peer[0];\n            const host = peer[1];\n            let version = '';\n            let pruningLimit = undefined;\n            let tcp = null;\n            let ssl = null;\n            let wss = null;\n            for (const meta of peer[2]) {\n                switch (meta.charAt(0)) {\n                    case 'v':\n                        version = meta.substring(1);\n                        break;\n                    case 'p':\n                        pruningLimit = Number.parseInt(meta.substring(1), 10);\n                        break;\n                    case 't':\n                        {\n                            if (meta.substring(1).length === 0) {\n                                switch (this.options.network || BitcoinJS.networks.bitcoin) {\n                                    case BitcoinJS.networks.testnet:\n                                        tcp = 60001;\n                                        break;\n                                    default:\n                                        tcp = 50001;\n                                        break;\n                                }\n                            }\n                            else {\n                                tcp = Number.parseInt(meta.substring(1), 10);\n                            }\n                        }\n                        break;\n                    case 's':\n                        {\n                            if (meta.substring(1).length === 0) {\n                                switch (this.options.network || BitcoinJS.networks.bitcoin) {\n                                    case BitcoinJS.networks.testnet:\n                                        ssl = 60002;\n                                        break;\n                                    default:\n                                        ssl = 50002;\n                                        break;\n                                }\n                            }\n                            else {\n                                ssl = Number.parseInt(meta.substring(1), 10);\n                            }\n                        }\n                        break;\n                    case 'w':\n                        {\n                            if (meta.substring(1).length === 0) {\n                                switch (this.options.network || BitcoinJS.networks.bitcoin) {\n                                    case BitcoinJS.networks.testnet:\n                                        wss = 60004;\n                                        break;\n                                    default:\n                                        wss = 50004;\n                                        break;\n                                }\n                            }\n                            else {\n                                wss = Number.parseInt(meta.substring(1), 10);\n                            }\n                        }\n                        break;\n                }\n            }\n            return {\n                ip,\n                host,\n                version,\n                pruningLimit,\n                ports: {\n                    tcp,\n                    ssl,\n                    wss,\n                },\n            };\n        });\n    }\n    ping() {\n        return this.socket.request('server.ping');\n    }\n    close(reason) {\n        return this.socket.close(reason);\n    }\n    async addressToScriptHash(addr) {\n        const outputScript = BitcoinJS.address.toOutputScript(addr, this.options.network);\n        const hash = new Uint8Array(await crypto.subtle.digest('SHA-256', outputScript));\n        return bytesToHex(hash.reverse());\n    }\n}\n","import * as BitcoinJS from 'bitcoinjs-lib';\nimport { Buffer } from 'buffer';\nimport { bytesToHex, hexToBytes } from '../electrum-ws';\nexport function blockHeaderToPlain(header, height) {\n    if (typeof header === 'string')\n        header = BitcoinJS.Block.fromHex(header);\n    return {\n        blockHash: header.getId(),\n        blockHeight: height,\n        timestamp: header.timestamp,\n        bits: header.bits,\n        nonce: header.nonce,\n        version: header.version,\n        weight: header.weight(),\n        prevHash: header.prevHash ? bytesToHex(new Uint8Array(header.prevHash).reverse()) : null,\n        merkleRoot: header.merkleRoot ? bytesToHex(new Uint8Array(header.merkleRoot).reverse()) : null,\n    };\n}\nexport function transactionToPlain(tx, network) {\n    if (typeof tx === 'string')\n        tx = BitcoinJS.Transaction.fromHex(tx);\n    const inputs = tx.ins.map((input, index) => inputToPlain(input, index, network));\n    const outputs = tx.outs.map((output, index) => outputToPlain(output, index, network));\n    const plain = {\n        transactionHash: tx.getId(),\n        inputs,\n        outputs,\n        version: tx.version,\n        vsize: tx.virtualSize(),\n        isCoinbase: tx.isCoinbase(),\n        weight: tx.weight(),\n        locktime: tx.locktime,\n        replaceByFee: inputs.some(input => input.sequence < 0xfffffffe),\n    };\n    return plain;\n}\nexport function inputToPlain(input, index, network) {\n    let address = null;\n    try {\n        address = deriveAddressFromInput(input, network) || null;\n    }\n    catch (error) {\n        if (location.hostname === 'localhost')\n            console.error(error);\n    }\n    return {\n        script: bytesToHex(input.script),\n        transactionHash: bytesToHex(new Uint8Array(input.hash).reverse()),\n        address,\n        witness: input.witness.map((buf) => {\n            if (typeof buf === 'number')\n                return buf;\n            return bytesToHex(buf);\n        }),\n        index,\n        outputIndex: input.index,\n        sequence: input.sequence,\n    };\n}\nexport function outputToPlain(output, index, network) {\n    let address = null;\n    try {\n        address = BitcoinJS.address.fromOutputScript(output.script, network);\n    }\n    catch (error) {\n    }\n    return {\n        script: bytesToHex(output.script),\n        address,\n        value: output.value,\n        index,\n    };\n}\nexport function deriveAddressFromInput(input, network) {\n    if (BitcoinJS.Transaction.isCoinbaseHash(input.hash))\n        return undefined;\n    const chunks = (BitcoinJS.script.decompile(input.script) || []);\n    const witness = input.witness;\n    if (chunks.length === 2 && witness.length === 0) {\n        return BitcoinJS.payments.p2pkh({\n            pubkey: chunks[1],\n            network,\n        }).address;\n    }\n    if (chunks.length === 1 && witness.length === 2) {\n        return BitcoinJS.payments.p2sh({\n            redeem: BitcoinJS.payments.p2wpkh({\n                pubkey: witness[1],\n                network,\n            }),\n        }).address;\n    }\n    if (chunks.length === 0 && witness.length === 2) {\n        return BitcoinJS.payments.p2wpkh({\n            pubkey: witness[1],\n            network,\n        }).address;\n    }\n    if (chunks.length > 2 && witness.length === 0) {\n        const redeemScript = BitcoinJS.script.decompile(chunks[chunks.length - 1]);\n        if (!redeemScript) {\n            console.error(new Error('Cannot decode address from input'));\n            return undefined;\n        }\n        if (redeemScript[redeemScript.length - 1] === BitcoinJS.script.OPS.OP_CHECKMULTISIG) {\n            const m = chunks.length - 2;\n            const pubkeys = redeemScript.filter(n => typeof n !== 'number');\n            return BitcoinJS.payments.p2sh({\n                redeem: BitcoinJS.payments.p2ms({\n                    m,\n                    pubkeys,\n                    network,\n                }),\n            }).address;\n        }\n        if (redeemScript[0] === BitcoinJS.script.OPS.OP_IF) {\n            return BitcoinJS.payments.p2sh({\n                redeem: {\n                    output: chunks[chunks.length - 1],\n                },\n                network,\n            }).address;\n        }\n    }\n    if (chunks.length === 1 && witness.length > 2) {\n        const redeemScript = BitcoinJS.script.decompile(witness[witness.length - 1]);\n        if (!redeemScript) {\n            console.error(new Error('Cannot decode address from input'));\n            return undefined;\n        }\n        if (redeemScript[redeemScript.length - 1] === BitcoinJS.script.OPS.OP_CHECKMULTISIG) {\n            const m = witness.length - 2;\n            const pubkeys = BitcoinJS.script.decompile(witness[witness.length - 1])\n                .filter(n => typeof n !== 'number');\n            return BitcoinJS.payments.p2sh({\n                redeem: BitcoinJS.payments.p2wsh({\n                    redeem: BitcoinJS.payments.p2ms({\n                        m,\n                        pubkeys,\n                        network,\n                    }),\n                }),\n            }).address;\n        }\n        if (witness.length === 3 && redeemScript.filter(n => typeof n !== 'number').length === 1) {\n            return BitcoinJS.payments.p2sh({\n                redeem: BitcoinJS.payments.p2wsh({\n                    redeem: BitcoinJS.payments.p2pkh({\n                        pubkey: witness[1],\n                        network,\n                    }),\n                }),\n            }).address;\n        }\n    }\n    if (chunks.length === 0 && witness.length > 2) {\n        const redeemScript = BitcoinJS.script.decompile(witness[witness.length - 1]);\n        if (!redeemScript) {\n            console.error(new Error('Cannot decode address from input'));\n            return undefined;\n        }\n        if (redeemScript[redeemScript.length - 1] === BitcoinJS.script.OPS.OP_CHECKMULTISIG) {\n            const m = witness.length - 2;\n            const pubkeys = redeemScript.filter(n => typeof n !== 'number');\n            return BitcoinJS.payments.p2wsh({\n                redeem: BitcoinJS.payments.p2ms({\n                    m,\n                    pubkeys,\n                    network,\n                }),\n            }).address;\n        }\n        if (redeemScript[0] === BitcoinJS.script.OPS.OP_IF) {\n            return BitcoinJS.payments.p2wsh({\n                witness,\n                network,\n            }).address;\n        }\n    }\n    console.error(new Error('Cannot decode address from input'));\n    return undefined;\n}\nexport function transactionFromPlain(plain) {\n    const tx = new BitcoinJS.Transaction();\n    tx.version = plain.version;\n    tx.locktime = plain.locktime;\n    tx.ins = plain.inputs.sort((a, b) => a.index - b.index).map(input => inputFromPlain(input));\n    tx.outs = plain.outputs.sort((a, b) => a.index - b.index).map(output => outputFromPlain(output));\n    return tx;\n}\nexport function inputFromPlain(plain) {\n    return {\n        hash: Buffer.from(hexToBytes(plain.transactionHash).reverse()),\n        index: plain.outputIndex,\n        script: Buffer.from(hexToBytes(plain.script)),\n        sequence: plain.sequence,\n        witness: plain.witness.map(scriptOrNumber => typeof scriptOrNumber === 'string' ? Buffer.from(hexToBytes(scriptOrNumber)) : scriptOrNumber),\n    };\n}\nexport function outputFromPlain(plain) {\n    return {\n        script: Buffer.from(hexToBytes(plain.script)),\n        value: plain.value,\n    };\n}\n","export * from './types';\nexport * from './helpers';\nexport * from './ElectrumApi';\n","export var Transport;\n(function (Transport) {\n    Transport[Transport[\"TCP\"] = 1] = \"TCP\";\n    Transport[Transport[\"SSL\"] = 2] = \"SSL\";\n    Transport[Transport[\"WSS\"] = 3] = \"WSS\";\n})(Transport || (Transport = {}));\n","import { ElectrumApi } from '../electrum-api/ElectrumApi';\nimport { Observable } from '../electrum-ws/Observable';\nimport { Transport } from '../electrum-api/types';\nimport { GenesisConfig, Network } from './GenesisConfig';\nimport { TransactionStore, BlockStore } from './Stores';\nimport { name as CLIENT_NAME, version as CLIENT_VERSION } from '../package.json';\nconst PROTOCOL_VERSION_MIN = '1.4';\nconst PROTOCOL_VERSION_MAX = '1.4.2';\nexport var Event;\n(function (Event) {\n    Event[\"BLOCK\"] = \"block\";\n    Event[\"TRANSACTION_ADDED\"] = \"transaction-added\";\n    Event[\"TRANSACTION_MINED\"] = \"transaction-mined\";\n    Event[\"SYNCING\"] = \"syncing\";\n    Event[\"SYNCED\"] = \"synced\";\n    Event[\"CLOSE\"] = \"close\";\n})(Event || (Event = {}));\nconst HANDSHAKE_TIMEOUT = 1000 * 4;\nconst PING_TIMEOUT = 1000 * 10;\nconst CONNECTIVITY_CHECK_INTERVAL = 1000 * 60;\nexport class Agent extends Observable {\n    constructor(peer, options = {}) {\n        super();\n        this.connection = null;\n        this.handshaking = false;\n        this.syncing = false;\n        this.synced = false;\n        this.orphanedBlocks = [];\n        this.knownReceipts = new Map();\n        this.pingInterval = -1;\n        this.peer = peer;\n        this.options = {\n            tcpProxyUrl: 'wss://electrum.nimiq.network:50001',\n            sslProxyUrl: 'wss://electrum.nimiq.network:50002',\n            ...options,\n        };\n        const transport = this.peer.preferTransport && peer.ports[this.transportToString(this.peer.preferTransport)]\n            ? this.peer.preferTransport\n            : undefined;\n        if (peer.ports.wss && (!transport || transport === Transport.WSS)) {\n            console.debug(`Agent: Connecting to wss://${peer.host}:${peer.ports.wss}/${peer.wssPath || ''}`);\n            this.transport = Transport.WSS;\n            this.connection = new ElectrumApi({\n                network: GenesisConfig.NETWORK_NAME,\n                endpoint: `wss://${peer.host}:${peer.ports.wss}/${peer.wssPath || ''}`,\n                proxy: false,\n            });\n        }\n        else if (peer.ports.ssl && this.options.sslProxyUrl && (!transport || transport === Transport.SSL)) {\n            console.debug(`Agent: Connecting to ssl://${peer.host}:${peer.ports.ssl}`);\n            this.transport = Transport.SSL;\n            this.connection = new ElectrumApi({\n                network: GenesisConfig.NETWORK_NAME,\n                endpoint: this.options.sslProxyUrl,\n                proxy: true,\n                token: `${this.networkToTokenPrefix(GenesisConfig.NETWORK_NAME)}:${peer.host}`\n            });\n        }\n        else if (peer.ports.tcp && this.options.tcpProxyUrl && (!transport || transport === Transport.TCP)) {\n            console.debug(`Agent: Connecting to tcp://${peer.host}:${peer.ports.tcp}`);\n            this.transport = Transport.TCP;\n            this.connection = new ElectrumApi({\n                network: GenesisConfig.NETWORK_NAME,\n                endpoint: this.options.tcpProxyUrl,\n                proxy: true,\n                token: `${this.networkToTokenPrefix(GenesisConfig.NETWORK_NAME)}:${peer.host}`\n            });\n        }\n        else {\n            throw new Error('No suitable transport protocol and port for peer');\n        }\n    }\n    async sync() {\n        if (this.handshaking || this.syncing || this.synced)\n            return;\n        await this.connection.waitForConnectionEstablished();\n        this.handshaking = true;\n        await this.handshake();\n        this.handshaking = false;\n        this.syncing = true;\n        this.fire(Event.SYNCING);\n        const promise = new Promise((resolve, reject) => {\n            this.once(Event.BLOCK, () => {\n                clearTimeout(timeout);\n                resolve(this.synced);\n            });\n            const timeout = setTimeout(() => reject(new Error('Block timeout')), HANDSHAKE_TIMEOUT);\n        });\n        this.requestHead();\n        return promise;\n    }\n    async getBalance(address) {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getBalance(address);\n    }\n    async getTransactionReceipts(address) {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getReceipts(address);\n    }\n    async getTransaction(hash, block) {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getTransaction(hash, block);\n    }\n    async getBlockHeader(height) {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getBlockHeader(height);\n    }\n    async estimateFees(targetBlocks) {\n        const requests = targetBlocks.map((target) => this.connection.estimateFee(target).catch(() => -1));\n        return Promise.all(requests);\n    }\n    async getFeeHistogram() {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getFeeHistogram();\n    }\n    async getMinimumRelayFee() {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getRelayFee();\n    }\n    async broadcastTransaction(rawTx) {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.broadcastTransaction(rawTx);\n    }\n    async subscribe(addresses) {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        if (typeof addresses === 'string')\n            addresses = [addresses];\n        for (const address of addresses) {\n            await this.connection.subscribeReceipts(address, (receipts) => this.onReceipts(address, receipts));\n        }\n    }\n    async getPeers() {\n        if (!this.synced)\n            throw new Error('Agent not synced');\n        return this.connection.getPeers();\n    }\n    close(reason) {\n        console.debug('Agent: Closed:', reason);\n        if (this.connection)\n            this.connection.close(reason);\n        this.connection = null;\n        this.syncing = false;\n        this.synced = false;\n        this.fire(Event.CLOSE, reason);\n        clearInterval(this.pingInterval);\n    }\n    on(event, callback) {\n        return super.on(event, callback);\n    }\n    once(event, callback) {\n        return super.once(event, callback);\n    }\n    off(event, id) {\n        return super.off(event, id);\n    }\n    allOff(event) {\n        return super.allOff(event);\n    }\n    async handshake() {\n        if (!this.connection) {\n            throw new Error('Agent not connected');\n        }\n        return new Promise(async (resolve, reject) => {\n            const timeout = setTimeout(() => reject(new Error('Handshake timeout')), HANDSHAKE_TIMEOUT);\n            try {\n                await this.connection.setProtocolVersion(`${CLIENT_NAME} ${CLIENT_VERSION}`, [PROTOCOL_VERSION_MIN, PROTOCOL_VERSION_MAX]);\n            }\n            catch (error) {\n                reject(new Error('Incompatible protocol version'));\n                return;\n            }\n            try {\n                const features = await this.connection.getFeatures();\n                if (features.genesis_hash !== GenesisConfig.GENESIS_HASH)\n                    throw new Error('Wrong genesis hash');\n            }\n            catch (error) {\n                reject(error);\n                return;\n            }\n            clearTimeout(timeout);\n            resolve(true);\n        });\n    }\n    async ping(failedTries = 0) {\n        const timeout = setTimeout(() => {\n            if (failedTries > 1)\n                this.close('Ping timeout');\n            else\n                this.ping(failedTries + 1);\n        }, PING_TIMEOUT);\n        try {\n            await this.connection.ping();\n            clearTimeout(timeout);\n        }\n        catch (error) {\n        }\n    }\n    requestHead() {\n        if (!this.connection) {\n            throw new Error('Agent not connected');\n        }\n        this.connection.subscribeHeaders(this.onBlock.bind(this));\n    }\n    async onBlock(block) {\n        let prevBlock = BlockStore.get(block.blockHeight - 1);\n        if (!prevBlock && block.blockHeight > 0) {\n            prevBlock = await this.connection.getBlockHeader(block.blockHeight - 1);\n            BlockStore.set(prevBlock.blockHeight, prevBlock);\n        }\n        if ((!prevBlock && block.blockHeight === 0) || prevBlock.blockHash === block.prevHash) {\n            BlockStore.set(block.blockHeight, block);\n            this.fire(Event.BLOCK, block);\n        }\n        else {\n            console.warn('Agent: Received non-consecutive block:', block);\n        }\n        if (this.syncing) {\n            this.syncing = false;\n            this.synced = true;\n            this.fire(Event.SYNCED);\n            this.pingInterval = window.setInterval(this.ping.bind(this), CONNECTIVITY_CHECK_INTERVAL);\n        }\n    }\n    async onReceipts(address, receipts) {\n        if (!this.knownReceipts.has(address)) {\n            this.knownReceipts.set(address, new Map(receipts.map(receipt => [receipt.transactionHash, receipt])));\n            return;\n        }\n        const knownReceipts = this.knownReceipts.get(address);\n        for (const receipt of receipts) {\n            const knownReceipt = knownReceipts.get(receipt.transactionHash);\n            if (knownReceipt && knownReceipt.blockHeight === receipt.blockHeight)\n                continue;\n            let block = undefined;\n            if (receipt.blockHeight > 0) {\n                block = BlockStore.get(receipt.blockHeight);\n                if (!block) {\n                    block = await this.getBlockHeader(receipt.blockHeight);\n                    BlockStore.set(block.blockHeight, block);\n                }\n            }\n            const storedTransaction = TransactionStore.get(receipt.transactionHash);\n            let txCheck;\n            if (!storedTransaction) {\n                txCheck = this.connection.getTransaction(receipt.transactionHash, block);\n                txCheck.then(tx => TransactionStore.set(tx.transactionHash, tx)).catch(() => { });\n            }\n            else {\n                txCheck = block\n                    ? this.connection.proofTransaction(storedTransaction.transactionHash, block).then(() => storedTransaction)\n                    : Promise.resolve(storedTransaction);\n            }\n            txCheck.then(tx => {\n                if (block)\n                    this.fire(Event.TRANSACTION_MINED, tx, block);\n                else\n                    this.fire(Event.TRANSACTION_ADDED, tx);\n            }).catch(error => console.error(error));\n        }\n    }\n    networkToTokenPrefix(name) {\n        if (name === Network.MAIN)\n            return 'mainnet';\n        if (name === Network.TEST)\n            return 'testnet';\n    }\n    transportToString(transport) {\n        switch (transport) {\n            case Transport.WSS: return 'wss';\n            case Transport.SSL: return 'ssl';\n            case Transport.TCP: return 'tcp';\n        }\n    }\n}\n","import { transactionFromPlain } from '../electrum-api';\nimport { Transport } from '../electrum-api/types';\nimport { Agent, Event as AgentEvent } from './Agent';\nimport { ConsensusState, TransactionState, } from './types';\nimport { BlockStore, TransactionStore } from './Stores';\nimport { GenesisConfig, Network } from './GenesisConfig';\nexport class ElectrumClient {\n    constructor(options = {}) {\n        this.consensusState = ConsensusState.CONNECTING;\n        this.head = null;\n        this.agents = new Set();\n        this.addressBook = new Map();\n        this.subscribedAddresses = new Set();\n        this.consensusChangedListeners = new Map();\n        this.headChangedListeners = new Map();\n        this.transactionListeners = new Map();\n        this.listenerId = 0;\n        this.transactionsWaitingForConfirmation = new Map();\n        this.options = {\n            requiredBlockConfirmations: 6,\n            extraSeedPeers: [],\n            ...options,\n        };\n        this.resetPeers();\n        this.connect();\n    }\n    getHeadHash() {\n        var _a;\n        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.blockHash;\n    }\n    getHeadHeight() {\n        var _a;\n        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.blockHeight;\n    }\n    getHeadBlock() {\n        return this.head || undefined;\n    }\n    async getBlockAt(height) {\n        const storedBlock = BlockStore.get(height);\n        if (storedBlock)\n            return storedBlock;\n        for (const agent of this.agents) {\n            try {\n                return await agent.getBlockHeader(height);\n            }\n            catch (error) {\n                console.warn(`Client: failed to get block header at ${height} from ${agent.peer.host}:`, error.message);\n            }\n        }\n        throw new Error(`Failed to get block header at ${height}`);\n    }\n    async getBalance(address) {\n        for (const agent of this.agents) {\n            try {\n                return await agent.getBalance(address);\n            }\n            catch (error) {\n                console.warn(`Client: failed to get balance for ${address} from ${agent.peer.host}:`, error.message);\n            }\n        }\n        throw new Error(`Failed to get balance for ${address}`);\n    }\n    async getTransaction(hash, block) {\n        if (!block) {\n            const storedTransaction = TransactionStore.get(hash);\n            if (storedTransaction)\n                return storedTransaction;\n        }\n        for (const agent of this.agents) {\n            try {\n                return await agent.getTransaction(hash, block);\n            }\n            catch (error) {\n                console.warn(`Client: failed to get transaction ${hash} from ${agent.peer.host}:`, error.message);\n            }\n        }\n        throw new Error(`Failed to get transaction ${hash}`);\n    }\n    async getTransactionReceiptsByAddress(address) {\n        for (const agent of this.agents) {\n            try {\n                return await agent.getTransactionReceipts(address);\n            }\n            catch (error) {\n                console.warn(`Client: failed to get transaction receipts for ${address} from ${agent.peer.host}:`, error.message);\n            }\n        }\n        throw new Error(`Failed to get transaction receipts for ${address}`);\n    }\n    async getTransactionsByAddress(address, sinceBlockHeight = 0, knownTransactions = [], limit = Infinity) {\n        const knownTxs = new Map();\n        if (knownTransactions) {\n            for (const tx of knownTransactions) {\n                knownTxs.set(tx.transactionHash, tx);\n            }\n        }\n        let history = await this.getTransactionReceiptsByAddress(address);\n        if (limit < Infinity) {\n            history = history.slice(0, limit);\n        }\n        if (sinceBlockHeight > 0) {\n            const firstUnwantedHistoryIndex = history.findIndex(receipt => receipt.blockHeight > 0 && receipt.blockHeight < sinceBlockHeight);\n            if (firstUnwantedHistoryIndex > -1) {\n                history = history.slice(0, firstUnwantedHistoryIndex);\n            }\n        }\n        const blocks = new Map();\n        const txs = [];\n        for (const { transactionHash, blockHeight } of history) {\n            const knownTx = knownTxs.get(transactionHash);\n            if (knownTx && knownTx.blockHeight === Math.max(blockHeight, 0) && knownTx.state === TransactionState.CONFIRMED) {\n                continue;\n            }\n            try {\n                let block = blocks.get(blockHeight);\n                if (!block && blockHeight > 0) {\n                    block = await this.getBlockAt(blockHeight);\n                    blocks.set(blockHeight, block);\n                }\n                try {\n                    const tx = await this.getTransaction(transactionHash, block);\n                    let confirmations = 0;\n                    let state = TransactionState.PENDING;\n                    if (block) {\n                        confirmations = this.head.blockHeight - block.blockHeight + 1;\n                        const confirmed = confirmations >= this.options.requiredBlockConfirmations;\n                        state = confirmed ? TransactionState.CONFIRMED : TransactionState.MINED;\n                    }\n                    const details = {\n                        ...tx,\n                        state,\n                        confirmations,\n                        ...(block ? {\n                            blockHash: block.blockHash,\n                            blockHeight: block.blockHeight,\n                            timestamp: block.timestamp,\n                        } : {}),\n                    };\n                    if (details.state === TransactionState.MINED)\n                        this.queueTransactionForConfirmation(details);\n                    txs.push(details);\n                }\n                catch (error) {\n                    console.warn(error);\n                    continue;\n                }\n            }\n            catch (error) {\n                console.warn(error);\n                return txs;\n            }\n        }\n        for (const details of knownTxs.values()) {\n            if ((details.state === TransactionState.NEW || details.state === TransactionState.PENDING)\n                && !txs.some((tx) => tx.transactionHash === details.transactionHash)) {\n                txs.push(await this.sendTransaction(transactionFromPlain(details).toHex()));\n            }\n        }\n        return txs;\n    }\n    async sendTransaction(serializedTx) {\n        var _a, _b;\n        let tx;\n        let sendError;\n        for (const agent of this.agents) {\n            try {\n                tx = await agent.broadcastTransaction(serializedTx);\n            }\n            catch (error) {\n                sendError = error;\n                console.warn(`Client: failed to broadcast transaction to ${agent.peer.host}:`, error.message);\n            }\n        }\n        if (!tx) {\n            throw (sendError || new Error('Could not send transaction'));\n        }\n        if (tx.onChain) {\n            const address = ((_a = tx.inputs.find(input => input.address)) === null || _a === void 0 ? void 0 : _a.address) || ((_b = tx.outputs.find(output => output.address)) === null || _b === void 0 ? void 0 : _b.address);\n            const receipts = await this.getTransactionReceiptsByAddress(address);\n            const blockHeight = receipts.find(receipt => receipt.transactionHash === tx.transactionHash).blockHeight;\n            const block = await this.getBlockAt(blockHeight);\n            return this.onMinedTransaction(block, tx, this.head || undefined);\n        }\n        this.onPendingTransaction(tx);\n        return {\n            ...tx,\n            state: TransactionState.PENDING,\n            confirmations: 0,\n        };\n    }\n    async estimateFees(targetBlocks = [25, 10, 5, 2]) {\n        const estimates = [];\n        for (const agent of this.agents) {\n            try {\n                estimates.push(await agent.estimateFees(targetBlocks));\n            }\n            catch (error) {\n                console.warn(`Client: failed to get fee estimate from ${agent.peer.host}:`, error.message);\n            }\n        }\n        if (!estimates.length) {\n            throw new Error(`Failed to get fee estimates`);\n        }\n        function median(array) {\n            if (!array.length)\n                return undefined;\n            const middleIndex = Math.floor(array.length / 2);\n            const sorted = [...array].sort();\n            return array.length % 2 !== 0\n                ? sorted[middleIndex]\n                : Math.round((sorted[middleIndex - 1] + sorted[middleIndex]) / 2);\n        }\n        ;\n        const result = {};\n        for (const target of targetBlocks) {\n            const i = targetBlocks.indexOf(target);\n            const feesForTarget = estimates.map(estimate => estimate[i]).filter(estimate => estimate > 0);\n            result[target] = median(feesForTarget);\n        }\n        return result;\n    }\n    async getMempoolFees() {\n        for (const agent of this.agents) {\n            try {\n                return await agent.getFeeHistogram();\n            }\n            catch (error) {\n                console.warn(`Client: failed to get mempool fees from ${agent.peer.host}:`, error.message);\n            }\n        }\n        throw new Error(`Failed to get mempool fees`);\n    }\n    async getMinimumRelayFee() {\n        for (const agent of this.agents) {\n            try {\n                return await agent.getMinimumRelayFee();\n            }\n            catch (error) {\n                console.warn(`Client: failed to get relay fee from ${agent.peer.host}:`, error.message);\n            }\n        }\n        throw new Error(`Failed to get relay fee`);\n    }\n    addConsensusChangedListener(listener) {\n        const listenerId = this.listenerId++;\n        this.consensusChangedListeners.set(listenerId, listener);\n        return listenerId;\n    }\n    addHeadChangedListener(listener) {\n        const listenerId = this.listenerId++;\n        this.headChangedListeners.set(listenerId, listener);\n        return listenerId;\n    }\n    addTransactionListener(listener, addresses) {\n        const set = new Set(addresses);\n        for (const address of set) {\n            this.subscribedAddresses.add(address);\n        }\n        if (this.consensusState === ConsensusState.ESTABLISHED) {\n            for (const agent of this.agents) {\n                agent.subscribe([...this.subscribedAddresses.values()]);\n            }\n        }\n        const listenerId = this.listenerId++;\n        this.transactionListeners.set(listenerId, { listener, addresses: set });\n        return listenerId;\n    }\n    removeListener(handle) {\n        this.consensusChangedListeners.delete(handle);\n        this.headChangedListeners.delete(handle);\n        this.transactionListeners.delete(handle);\n        if (this.transactionListeners.size === 0) {\n            this.transactionsWaitingForConfirmation.clear();\n        }\n    }\n    async waitForConsensusEstablished() {\n        return new Promise(resolve => {\n            if (this.consensusState === ConsensusState.ESTABLISHED) {\n                resolve();\n            }\n            else {\n                const handle = this.addConsensusChangedListener(state => {\n                    if (state === ConsensusState.ESTABLISHED) {\n                        this.removeListener(handle);\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    async connect() {\n        this.onConsensusChanged(ConsensusState.CONNECTING);\n        if (this.addressBook.size === 0)\n            this.resetPeers();\n        let peers = [];\n        for (const transport of [Transport.WSS, Transport.SSL, Transport.TCP]) {\n            peers = [...this.addressBook.values()].filter((peer) => {\n                const protocol = [null, 'tcp', 'ssl', 'wss'][transport];\n                if (!peer.ports[protocol])\n                    return false;\n                if (peer.preferTransport && peer.preferTransport < transport)\n                    return false;\n                return true;\n            });\n            if (peers.length > 0)\n                break;\n        }\n        const highPriorityPeers = peers.filter(peer => peer.highPriority);\n        if (highPriorityPeers.length > 0)\n            peers = highPriorityPeers;\n        const peer = peers[Math.floor(Math.random() * peers.length)];\n        const agentOptions = this.options.websocketProxy\n            ? {\n                tcpProxyUrl: this.options.websocketProxy.tcp,\n                sslProxyUrl: this.options.websocketProxy.ssl,\n            }\n            : undefined;\n        const agent = new Agent(peer, agentOptions);\n        agent.on(AgentEvent.SYNCING, () => this.onConsensusChanged(ConsensusState.SYNCING));\n        agent.on(AgentEvent.SYNCED, () => {\n            this.agents.add(agent);\n            this.onConsensusChanged(ConsensusState.ESTABLISHED);\n        });\n        agent.on(AgentEvent.BLOCK, (block) => this.onHeadChanged(block, 'extended', [], [block]));\n        agent.on(AgentEvent.TRANSACTION_ADDED, (tx) => this.onPendingTransaction(tx));\n        agent.on(AgentEvent.TRANSACTION_MINED, (tx, block) => this.onMinedTransaction(block, tx, block));\n        agent.on(AgentEvent.CLOSE, (reason) => this.onConsensusFailed(agent, reason));\n        try {\n            await agent.sync();\n        }\n        catch (error) {\n            this.removePeer(agent.peer, agent.transport);\n            agent.close(error.message);\n            return;\n        }\n        this.addPeers(await agent.getPeers());\n    }\n    resetPeers() {\n        if (this.addressBook.size > 0)\n            this.addressBook.clear();\n        this.addPeers(GenesisConfig.SEED_PEERS);\n        this.addPeers(this.options.extraSeedPeers);\n    }\n    addPeers(peers) {\n        peers = peers.filter(peer => {\n            if (peer.host.endsWith('.onion'))\n                return false;\n            if (peer.ports.ssl && peer.ports.ssl !== (GenesisConfig.NETWORK_NAME === Network.MAIN ? 50002 : 60002))\n                return false;\n            if (peer.ports.tcp && peer.ports.tcp !== (GenesisConfig.NETWORK_NAME === Network.MAIN ? 50001 : 60001))\n                return false;\n            return true;\n        });\n        for (const peer of peers) {\n            this.addressBook.set(peer.host, peer);\n        }\n    }\n    removePeer(peer, transport) {\n        if (peer.highPriority) {\n            peer.highPriority = false;\n            this.addressBook.set(peer.host, peer);\n            return;\n        }\n        switch (transport) {\n            case Transport.WSS:\n                if (peer.ports['ssl']) {\n                    peer.preferTransport = Transport.SSL;\n                    this.addressBook.set(peer.host, peer);\n                    return;\n                }\n            case Transport.SSL:\n                if (peer.ports['tcp']) {\n                    peer.preferTransport = Transport.TCP;\n                    this.addressBook.set(peer.host, peer);\n                    return;\n                }\n            case Transport.TCP:\n                delete peer.preferTransport;\n                this.addressBook.delete(peer.host);\n                return;\n        }\n    }\n    getConfirmationHeight(blockHeight) {\n        return blockHeight + this.options.requiredBlockConfirmations - 1;\n    }\n    queueTransactionForConfirmation(tx) {\n        if (!tx.blockHeight)\n            return;\n        const confirmationHeight = this.getConfirmationHeight(tx.blockHeight);\n        const map = this.transactionsWaitingForConfirmation.get(confirmationHeight) || new Map();\n        map.set(tx.transactionHash, tx);\n        this.transactionsWaitingForConfirmation.set(confirmationHeight, map);\n    }\n    clearTransactionFromConfirm(tx) {\n        for (const [key, value] of this.transactionsWaitingForConfirmation.entries()) {\n            if (value.has(tx.transactionHash)) {\n                value.delete(tx.transactionHash);\n                if (value.size === 0) {\n                    this.transactionsWaitingForConfirmation.delete(key);\n                    break;\n                }\n            }\n        }\n    }\n    onConsensusChanged(state) {\n        if (state === this.consensusState)\n            return;\n        this.consensusState = state;\n        for (const listener of this.consensusChangedListeners.values()) {\n            listener(state);\n        }\n        if (state === ConsensusState.ESTABLISHED) {\n            if (this.subscribedAddresses.size > 0) {\n                for (const agent of this.agents) {\n                    agent.subscribe([...this.subscribedAddresses.values()]);\n                }\n            }\n            if (!this.head)\n                return;\n            for (const listener of this.headChangedListeners.values()) {\n                listener(this.head, 'established', [], [this.head.blockHash]);\n            }\n        }\n    }\n    onConsensusFailed(agent, reason) {\n        if (agent) {\n            agent.allOff(AgentEvent.SYNCING);\n            agent.allOff(AgentEvent.SYNCED);\n            agent.allOff(AgentEvent.BLOCK);\n            agent.allOff(AgentEvent.TRANSACTION_ADDED);\n            agent.allOff(AgentEvent.TRANSACTION_MINED);\n            agent.allOff(AgentEvent.CLOSE);\n            this.agents.delete(agent);\n        }\n        console.debug('Client: Consensus failed: last agent closed');\n        this.connect();\n    }\n    onHeadChanged(block, reason, revertedBlocks, adoptedBlocks) {\n        const previousBlock = this.head;\n        this.head = block;\n        if (this.consensusState === ConsensusState.ESTABLISHED && (!previousBlock || block.blockHash !== previousBlock.blockHash)) {\n            for (const listener of this.headChangedListeners.values()) {\n                listener(block, reason, revertedBlocks.map(b => b.blockHash), adoptedBlocks.map(b => b.blockHash));\n            }\n        }\n        if (this.transactionListeners.size > 0) {\n            const revertedTxs = new Set();\n            for (const block of revertedBlocks) {\n                const confirmationHeight = this.getConfirmationHeight(block.blockHeight);\n                const map = this.transactionsWaitingForConfirmation.get(confirmationHeight);\n                if (map) {\n                    for (const tx of map.values()) {\n                        revertedTxs.add(tx);\n                    }\n                    this.transactionsWaitingForConfirmation.delete(confirmationHeight);\n                }\n            }\n            for (const tx of revertedTxs.values()) {\n                this.onPendingTransaction(tx);\n            }\n            for (const block of adoptedBlocks) {\n                const map = this.transactionsWaitingForConfirmation.get(block.blockHeight);\n                if (map) {\n                    for (const tx of map.values()) {\n                        this.onConfirmedTransaction(tx, adoptedBlocks[adoptedBlocks.length - 1]);\n                    }\n                    this.transactionsWaitingForConfirmation.delete(block.blockHeight);\n                }\n            }\n        }\n    }\n    onPendingTransaction(tx) {\n        const details = {\n            ...tx,\n            state: TransactionState.PENDING,\n            confirmations: 0,\n        };\n        for (const { listener } of this.getListenersForTransaction(tx)) {\n            listener(details);\n        }\n        this.clearTransactionFromConfirm(tx);\n        return details;\n    }\n    onMinedTransaction(block, tx, blockNow) {\n        let state = TransactionState.MINED;\n        let confirmations = 1;\n        if (blockNow) {\n            confirmations = (blockNow.blockHeight - block.blockHeight) + 1;\n            state = confirmations >= this.options.requiredBlockConfirmations ? TransactionState.CONFIRMED : TransactionState.MINED;\n        }\n        const details = {\n            ...tx,\n            blockHash: block.blockHash,\n            blockHeight: block.blockHeight,\n            timestamp: block.timestamp,\n            state,\n            confirmations,\n        };\n        for (const { listener } of this.getListenersForTransaction(tx)) {\n            listener(details);\n        }\n        if (details && details.state === TransactionState.MINED) {\n            this.queueTransactionForConfirmation(details);\n        }\n        return details;\n    }\n    onConfirmedTransaction(tx, blockNow) {\n        const details = {\n            ...tx,\n            state: TransactionState.CONFIRMED,\n            confirmations: blockNow.blockHeight - tx.blockHeight,\n        };\n        for (const { listener } of this.getListenersForTransaction(tx)) {\n            listener(details);\n        }\n        return details;\n    }\n    getListenersForTransaction(tx) {\n        return [...this.transactionListeners.values()].filter(({ addresses }) => tx.inputs.some(input => input.address && addresses.has(input.address))\n            || tx.outputs.some(output => output.address && addresses.has(output.address)));\n    }\n}\n","import * as BitcoinJS from 'bitcoinjs-lib';\nexport var Network;\n(function (Network) {\n    Network[\"MAIN\"] = \"bitcoin\";\n    Network[\"TEST\"] = \"testnet\";\n})(Network || (Network = {}));\nexport class GenesisConfig {\n    static main() {\n        GenesisConfig.init(GenesisConfig.CONFIGS[Network.MAIN]);\n    }\n    static test() {\n        GenesisConfig.init(GenesisConfig.CONFIGS[Network.TEST]);\n    }\n    static init(config) {\n        if (GenesisConfig._config)\n            throw new Error('GenesisConfig already initialized');\n        if (!config.NETWORK_NAME)\n            throw new Error('Config is missing network name');\n        if (!config.GENESIS_HEADER)\n            throw new Error('Config is missing genesis header');\n        if (!config.SEED_PEERS)\n            throw new Error('Config is missing seed peers');\n        GenesisConfig._config = config;\n    }\n    static get NETWORK_NAME() {\n        if (!GenesisConfig._config)\n            throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_NAME;\n    }\n    static get GENESIS_HEADER() {\n        if (!GenesisConfig._config)\n            throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.GENESIS_HEADER;\n    }\n    static get GENESIS_HASH() {\n        if (!GenesisConfig._config)\n            throw new Error('GenesisConfig not initialized');\n        if (!GenesisConfig._config.GENESIS_HASH) {\n            GenesisConfig._config.GENESIS_HASH = BitcoinJS.Block.fromHex(GenesisConfig._config.GENESIS_HEADER).getId();\n        }\n        return GenesisConfig._config.GENESIS_HASH;\n    }\n    static get SEED_PEERS() {\n        if (!GenesisConfig._config)\n            throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.SEED_PEERS;\n    }\n    static get SEED_LISTS() {\n        if (!GenesisConfig._config)\n            throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.SEED_LISTS;\n    }\n}\nGenesisConfig.CONFIGS = {\n    'bitcoin': {\n        NETWORK_NAME: Network.MAIN,\n        SEED_PEERS: [\n            { host: 'electrum.blockstream.info', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'bitcoin.aranguren.org', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'bitcoin.lukechilds.co', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'skbxmit.coinjoined.com', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'electrumx.ultracloud.tk', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: 'btc.ultracloud.tk', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: 'btc.electrum.bitbitnet.net', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'electrum.coinext.com.br', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'endthefed.onthewifi.com', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: '2ex.digitaleveryware.com', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: '1electrumx.hopto.me', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'helicarrier.bauerj.eu', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'node1.btccuracao.com', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'ultracloud.tk', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: 'horsey.cryptocowboys.net', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'electrum-btc.leblancnet.us', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'caleb.vegas', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: 'alviss.coinjoined.com', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'gall.pro', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: 'electrum.syngularity.es', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'electrum2.privateservers.network', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n            { host: 'electrum.snekash.io', ports: { wss: null, ssl: 50002, tcp: null }, ip: '', version: '' },\n            { host: 'stavver.dyshek.org', ports: { wss: null, ssl: 50002, tcp: 50001 }, ip: '', version: '' },\n        ],\n        SEED_LISTS: [],\n        GENESIS_HEADER: '0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c',\n    },\n    'testnet': {\n        NETWORK_NAME: Network.TEST,\n        SEED_PEERS: [\n            { host: 'electrum.blockstream.info', ports: { wss: null, ssl: 60002, tcp: 60001 }, ip: '', version: '' },\n        ],\n        SEED_LISTS: [],\n        GENESIS_HEADER: '0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4adae5494dffff001d1aa4ae18',\n    },\n};\n","export const TransactionStore = new Map();\nexport const BlockStore = new Map();\n","export * from './types';\nexport * from './Agent';\nexport * from './Stores';\nexport * from './GenesisConfig';\nexport * from './ElectrumClient';\n","export var ConsensusState;\n(function (ConsensusState) {\n    ConsensusState[\"CONNECTING\"] = \"connecting\";\n    ConsensusState[\"SYNCING\"] = \"syncing\";\n    ConsensusState[\"ESTABLISHED\"] = \"established\";\n})(ConsensusState || (ConsensusState = {}));\nexport var TransactionState;\n(function (TransactionState) {\n    TransactionState[\"NEW\"] = \"new\";\n    TransactionState[\"PENDING\"] = \"pending\";\n    TransactionState[\"MINED\"] = \"mined\";\n    TransactionState[\"INVALIDATED\"] = \"invalidated\";\n    TransactionState[\"CONFIRMED\"] = \"confirmed\";\n})(TransactionState || (TransactionState = {}));\n","import { Observable } from './Observable';\nimport { stringToBytes, bytesToString } from './helpers';\nexport var ElectrumWSEvent;\n(function (ElectrumWSEvent) {\n    ElectrumWSEvent[\"OPEN\"] = \"open\";\n    ElectrumWSEvent[\"CLOSE\"] = \"close\";\n    ElectrumWSEvent[\"CONNECTED\"] = \"connected\";\n    ElectrumWSEvent[\"DISCONNECTED\"] = \"disconnected\";\n    ElectrumWSEvent[\"RECONNECTING\"] = \"reconnecting\";\n    ElectrumWSEvent[\"ERROR\"] = \"error\";\n    ElectrumWSEvent[\"MESSAGE\"] = \"message\";\n})(ElectrumWSEvent || (ElectrumWSEvent = {}));\nexport const DEFAULT_ENDPOINT = 'wss://api.nimiqwatch.com:50002';\nexport const DEFAULT_TOKEN = 'mainnet:electrum.blockstream.info';\nconst RECONNECT_TIMEOUT = 1000;\nconst CONNECTED_TIMEOUT = 500;\nconst REQUEST_TIMEOUT = 1000 * 10;\nconst CLOSE_CODE = 1000;\nexport class ElectrumWS extends Observable {\n    constructor(endpoint = DEFAULT_ENDPOINT, options = {}) {\n        super();\n        this.requests = new Map();\n        this.subscriptions = new Map();\n        this.connected = false;\n        this.reconnectionTimeout = -1;\n        this.incompleteMessage = '';\n        this.endpoint = endpoint;\n        this.options = Object.assign({\n            proxy: true,\n            token: DEFAULT_TOKEN,\n            reconnect: true,\n        }, options);\n        this.connect();\n        Object.values(ElectrumWSEvent).forEach((ev) => {\n            this.on(ev, (e) => e\n                ? console.debug(`ElectrumWS - ${ev.toUpperCase()}:`, e)\n                : console.debug(`ElectrumWS - ${ev.toUpperCase()}`));\n        });\n    }\n    async request(method, ...params) {\n        let id;\n        do {\n            id = Math.ceil(Math.random() * 1e5);\n        } while (this.requests.has(id));\n        const payload = {\n            jsonrpc: \"2.0\",\n            method,\n            params,\n            id,\n        };\n        if (!this.connected) {\n            await new Promise((resolve) => this.once(ElectrumWSEvent.CONNECTED, () => resolve(true)));\n        }\n        const promise = new Promise((resolve, reject) => {\n            const timeout = window.setTimeout(() => {\n                this.requests.delete(id);\n                reject(new Error('Request timeout'));\n            }, REQUEST_TIMEOUT);\n            this.requests.set(id, {\n                resolve,\n                reject,\n                method,\n                timeout,\n            });\n        });\n        console.debug('ElectrumWS SEND:', method, ...params);\n        this.ws.send(this.options.proxy ? stringToBytes(JSON.stringify(payload) + '\\n') : JSON.stringify(payload));\n        return promise;\n    }\n    async subscribe(method, callback, ...params) {\n        const subscriptionKey = `${method}${typeof params[0] === 'string' ? `-${params[0]}` : ''}`;\n        this.subscriptions.set(subscriptionKey, callback);\n        if (!this.connected)\n            return;\n        callback(...params, await this.request(`${method}.subscribe`, ...params));\n    }\n    async unsubscribe(method, ...params) {\n        const subscriptionKey = `${method}${typeof params[0] === 'string' ? `-${params[0]}` : ''}`;\n        this.subscriptions.delete(subscriptionKey);\n        return this.request(`${method}.unsubscribe`, ...params);\n    }\n    isConnected() {\n        return this.connected;\n    }\n    async close(reason) {\n        this.options.reconnect = false;\n        for (const [id, request] of this.requests) {\n            window.clearTimeout(request.timeout);\n            this.requests.delete(id);\n            console.debug('Rejecting pending request:', request.method);\n            request.reject(new Error(reason));\n        }\n        window.clearTimeout(this.reconnectionTimeout);\n        if (this.ws.readyState === WebSocket.CONNECTING || this.ws.readyState === WebSocket.OPEN) {\n            const closingPromise = new Promise((resolve) => this.once(ElectrumWSEvent.CLOSE, () => resolve(true)));\n            this.ws.close(CLOSE_CODE, reason);\n            return closingPromise;\n        }\n    }\n    connect() {\n        let url = this.endpoint;\n        if (this.options.proxy && this.options.token) {\n            url = `${url}?token=${this.options.token}`;\n        }\n        this.ws = new WebSocket(url, this.options.proxy ? 'binary' : undefined);\n        this.ws.binaryType = 'arraybuffer';\n        this.ws.addEventListener('open', this.onOpen.bind(this));\n        this.ws.addEventListener('message', this.onMessage.bind(this));\n        this.ws.addEventListener('error', this.onError.bind(this));\n        this.ws.addEventListener('close', this.onClose.bind(this));\n    }\n    onOpen() {\n        this.fire(ElectrumWSEvent.OPEN);\n        this.connectedTimeout = window.setTimeout(() => {\n            this.connected = true;\n            this.fire(ElectrumWSEvent.CONNECTED);\n            for (const [subscriptionKey, callback] of this.subscriptions) {\n                const params = subscriptionKey.split('-');\n                const method = params.shift();\n                if (!method) {\n                    console.warn('Cannot resubscribe, no method in subscription key:', subscriptionKey);\n                    continue;\n                }\n                this.subscribe(method, callback, ...params).catch((error) => {\n                    if (this.ws.readyState === WebSocket.CONNECTING || this.ws.readyState === WebSocket.OPEN) {\n                        this.ws.close(CLOSE_CODE, error.message);\n                    }\n                });\n            }\n        }, CONNECTED_TIMEOUT);\n    }\n    onMessage(msg) {\n        const raw = typeof msg.data === 'string' ? msg.data : bytesToString(msg.data);\n        const lines = raw.split('\\n').filter(line => line.length > 0);\n        for (const line of lines) {\n            const response = this.parseLine(line);\n            if (!response)\n                continue;\n            this.fire(ElectrumWSEvent.MESSAGE, response);\n            if ('id' in response && this.requests.has(response.id)) {\n                const request = this.requests.get(response.id);\n                window.clearTimeout(request.timeout);\n                this.requests.delete(response.id);\n                if ('result' in response) {\n                    request.resolve(response.result);\n                }\n                else if (response.error) {\n                    request.reject(new Error(typeof response.error === 'string' ? response.error : response.error.message));\n                }\n                else {\n                    request.reject(new Error('No result'));\n                }\n            }\n            if ('method' in response && (response.method).endsWith('subscribe')) {\n                const method = response.method.replace('.subscribe', '');\n                const params = response.params || [];\n                const subscriptionKey = `${method}${typeof params[0] === 'string' ? `-${params[0]}` : ''}`;\n                if (this.subscriptions.has(subscriptionKey)) {\n                    const callback = this.subscriptions.get(subscriptionKey);\n                    callback(...params);\n                }\n            }\n        }\n    }\n    parseLine(line) {\n        try {\n            const parsed = JSON.parse(line);\n            this.incompleteMessage = '';\n            return parsed;\n        }\n        catch (error) {\n        }\n        if (this.incompleteMessage && !line.includes(this.incompleteMessage)) {\n            return this.parseLine(`${this.incompleteMessage}${line}`);\n        }\n        this.incompleteMessage = line;\n        return false;\n    }\n    onError(event) {\n        if (event.error) {\n            console.error('ElectrumWS ERROR:', event.error);\n            this.fire(ElectrumWSEvent.ERROR, event.error);\n        }\n    }\n    onClose(event) {\n        this.fire(ElectrumWSEvent.CLOSE, event);\n        if (!this.connected)\n            window.clearTimeout(this.connectedTimeout);\n        else\n            this.fire(ElectrumWSEvent.DISCONNECTED);\n        if (this.options.reconnect && this.connected) {\n            this.fire(ElectrumWSEvent.RECONNECTING);\n            this.reconnectionTimeout = window.setTimeout(() => this.connect(), RECONNECT_TIMEOUT);\n        }\n        this.connected = false;\n    }\n}\n","export class Observable {\n    constructor() {\n        this.listeners = new Map();\n    }\n    on(event, callback) {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, []);\n        }\n        return this.listeners.get(event).push(callback) - 1;\n    }\n    once(event, callback) {\n        const id = this.on(event, (...params) => {\n            this.off(event, id);\n            callback(...params);\n        });\n    }\n    off(event, id) {\n        const callbacks = this.listeners.get(event);\n        if (!callbacks || callbacks.length < id + 1)\n            return;\n        callbacks[id] = null;\n    }\n    allOff(event) {\n        this.listeners.delete(event);\n    }\n    fire(event, ...payload) {\n        const callbacks = this.listeners.get(event);\n        if (!callbacks || !callbacks.length)\n            return;\n        for (const callback of callbacks) {\n            if (!callback)\n                continue;\n            callback(...payload);\n        }\n    }\n}\n","export function stringToBytes(str) {\n    const encoder = new TextEncoder();\n    return encoder.encode(str);\n}\nexport function bytesToString(bytes) {\n    const decoder = new TextDecoder('utf-8');\n    return decoder.decode(bytes);\n}\nexport function hexToBytes(hex) {\n    return new Uint8Array((hex.match(/.{2}/g) || []).map(byte => parseInt(byte, 16)));\n}\nexport function bytesToHex(bytes) {\n    const HEX_ALPHABET = '0123456789abcdef';\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        const code = bytes[i];\n        hex += HEX_ALPHABET[code >>> 4];\n        hex += HEX_ALPHABET[code & 0x0F];\n    }\n    return hex;\n}\n","export * from './helpers';\nexport * from './ElectrumWS';\n","export * from './electrum-ws/index';\nexport * from './electrum-api/index';\nexport * from './electrum-client/index';\n"],"sourceRoot":""}