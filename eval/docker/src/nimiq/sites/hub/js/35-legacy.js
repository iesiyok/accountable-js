(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[35],{

/***/ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-sign-message-bitcoin.es.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-sign-message-bitcoin.es.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lazy_chunk_polyfill_node_buffer_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lazy-chunk-polyfill-node:buffer.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-polyfill-node:buffer.es.js");
/* harmony import */ var _lazy_chunk_request_bitcoin_es_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy-chunk-request-bitcoin.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-bitcoin.es.js");
/* harmony import */ var _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ledger-api.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/ledger-api.es.js");
/* harmony import */ var _lazy_chunk_request_es_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lazy-chunk-request.es.js */ "./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js");





class RequestSignMessageBitcoin extends _lazy_chunk_request_bitcoin_es_js__WEBPACK_IMPORTED_MODULE_1__["R"] {
    constructor(keyPath, message, expectedWalletId) {
        super(expectedWalletId);
        this.type = _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["RequestTypeBitcoin"].SIGN_MESSAGE;
        this.keyPath = keyPath;
        this.message = message;
        try {
            const parsedKeyPath = Object(_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["parseBip32Path"])(keyPath);
            if (parsedKeyPath.coin !== _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["Coin"].BITCOIN)
                throw new Error('Not a Bitcoin bip32 path following bip44');
            this.network = parsedKeyPath.network;
            this._addressType = parsedKeyPath.addressType;
        }
        catch (e) {
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["ErrorType"].REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}: ${e.message || e}`, this);
        }
    }
    async call(transport) {
        // Resources:
        // - Message signature specification (bip137):
        //   https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki
        //   Note that the message signatures generated by the Ledger are not based on the newer bip322 yet.
        // - Description of v, r, s values the signature consists of:
        //   https://bitcoin.stackexchange.com/a/38909
        // - Ledger Bitcoin App's api description:
        //   https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc#sign-message
        // - The implementation of the api call in @ledgerhq/hw-app-btc:
        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/signMessage.js
        //   Also handles the conversion of the ASN-1 encoded signature created by the Ledger (defined in
        //   https://www.secg.org/sec1-v2.pdf) to BitcoinQT format. However note that the returned v value does not
        //   contain the address type constant yet. For converting this result to the final concatenated base64
        //   signature including the address type see here:
        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/Btc.js#L92
        // - For confirming signed messages online:
        //   https://www.verifybitcoinmessage.com/
        // - bitcoinjs-message library for client side signing and verification of message signatures:
        //   https://github.com/bitcoinjs/bitcoinjs-message
        const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED on failure
        let messageBuffer;
        try {
            messageBuffer = typeof this.message === 'string'
                ? _lazy_chunk_polyfill_node_buffer_es_js__WEBPACK_IMPORTED_MODULE_0__["B"].from(this.message, 'utf8') // throws if invalid utf8
                : _lazy_chunk_polyfill_node_buffer_es_js__WEBPACK_IMPORTED_MODULE_0__["B"].from(this.message);
            if (messageBuffer.length >= 2 ** 16) {
                // the message length is encoded in two bytes and is 0 terminated.
                throw new Error('Message too long');
            }
        }
        catch (e) {
            throw new _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["ErrorState"](_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["ErrorType"].REQUEST_ASSERTION_FAILED, e, this);
        }
        if (this.network === _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["Network"].TESTNET && this._addressType === _ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].LEGACY) {
            console.warn('Ledgers seem to generate invalid signatures for testnet legacy p2pkh addresses. '
                + 'Prefer using nested p2sh segwit or native bech32 segwit addresses.');
        }
        // Note: We make api calls outside of the try...catch block to let the exceptions fall through such that
        // _callLedger can decide how to behave depending on the api error.
        const addressFormat = {
            [_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].LEGACY]: 'legacy',
            [_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].P2SH_SEGWIT]: 'p2sh',
            [_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].NATIVE_SEGWIT]: 'bech32',
        }[this._addressType];
        const { bitcoinAddress: signerAddress } = await api.getWalletPublicKey(this.keyPath, { format: addressFormat });
        const { v, // recId (not including the address type constant)
        r, // r of ECDSA signature
        s, } = await api.signMessageNew(this.keyPath, messageBuffer.toString('hex'));
        // Create the signature header, see
        // https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki#procedure-for-signingverifying-a-signature
        const headerAddressTypeConstant = {
            [_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].LEGACY]: 31,
            [_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].P2SH_SEGWIT]: 35,
            [_ledger_api_es_js__WEBPACK_IMPORTED_MODULE_2__["AddressTypeBitcoin"].NATIVE_SEGWIT]: 39,
        }[this._addressType];
        const header = (v + headerAddressTypeConstant).toString(16);
        const signature = _lazy_chunk_polyfill_node_buffer_es_js__WEBPACK_IMPORTED_MODULE_0__["B"].from(`${header}${r}${s}`, 'hex').toString('base64');
        return {
            signerAddress,
            signature,
        };
    }
}

/* harmony default export */ __webpack_exports__["default"] = (RequestSignMessageBitcoin);
//# sourceMappingURL=lazy-chunk-request-sign-message-bitcoin.es.js.map


/***/ })

}]);
//# sourceMappingURL=35-legacy.js.map