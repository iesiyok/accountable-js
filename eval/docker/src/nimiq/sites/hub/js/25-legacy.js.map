{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-withStaticURLs.es.js","sources://./node_modules/ws/browser.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAmF;AACM;AACtD;;AAEnC;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,4BAA4B,yDAAS;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,iEAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,gBAAgB,yDAAc;AAC9B;;AAEA;AACA;AACA,IAAI,iEAAG;AACP,WAAW,wEAAM;AACjB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,cAAc,yDAAc;AAC5B;AACA;;AAEA,kBAAkB,wEAAM,cAAc,mBAAO,CAAC,wCAAI;AAClD;AACA;AACA;;;AAGA,iCAAiC,yDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,kCAAkC;AAClC,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,yDAAc;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,yDAAc;;AAEtE;AACA,qDAAqD,wEAAM;AAC3D;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,yDAAc;AACjD;AACA;;AAEA;AACA;AACA,IAAI,iEAAG;AACP;AACA;;AAEA;;AAEA;AACA,KAAK;AACL,IAAI,iEAAG;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,iBAAiB,yDAAc;AAC/B;AACA;;AAEA;AACA,eAAe,yDAAc;AAC7B;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,yDAAS;;AAEzC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;AAEc,6EAAc,EAAC;AAC9B;;;;;;;;;;;;;AC5Qa;;AAEb;AACA;AACA;AACA;AACA;AACA","file":"js/25-legacy.js","sourcesContent":["import { B as Buffer, g as global } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { T as Transport, l as log, a as TransportError } from './lazy-chunk-index.es.js';\nimport './lazy-chunk-events.es.js';\n\n// For avoiding bundling the unnecessary axios dependency in @ledgerhq/hw-transport-http, we use fetch instead and\n// shim the required api parts of axios.\nfunction axiosShim({ url, method, headers, data, }) {\n    return fetch(url, {\n        method,\n        headers,\n        body: data,\n    });\n}\n\n/**\n * HTTP transport implementation\n */\n\nclass HttpTransport extends Transport {\n  // this transport is not discoverable\n  static async open(url, timeout) {\n    await HttpTransport.check(url, timeout);\n    return new HttpTransport(url);\n  }\n\n  constructor(url) {\n    super();\n    this.url = void 0;\n    this.url = url;\n  }\n\n  async exchange(apdu) {\n    const apduHex = apdu.toString(\"hex\");\n    log(\"apdu\", \"=> \" + apduHex);\n    const response = await axiosShim({\n      method: \"POST\",\n      url: this.url,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\"\n      },\n      data: JSON.stringify({\n        apduHex\n      })\n    });\n\n    if (response.status !== 200) {\n      throw new TransportError(\"failed to communicate to server. code=\" + response.status, \"HttpTransportStatus\" + response.status);\n    }\n\n    const body = await response.data;\n    if (body.error) throw body.error;\n    log(\"apdu\", \"<= \" + body.data);\n    return Buffer.from(body.data, \"hex\");\n  }\n\n  setScrambleKey() {}\n\n  close() {\n    return Promise.resolve();\n  }\n\n}\n\nHttpTransport.isSupported = () => Promise.resolve(typeof fetch === \"function\");\n\nHttpTransport.list = () => Promise.resolve([]);\n\nHttpTransport.listen = _observer => ({\n  unsubscribe: () => {}\n});\n\nHttpTransport.check = async (url, timeout = 5000) => {\n  const response = await axiosShim({\n    url,\n    timeout\n  });\n\n  if (response.status !== 200) {\n    throw new TransportError(\"failed to access HttpTransport(\" + url + \"): status \" + response.status, \"HttpTransportNotAccessible\");\n  }\n};\n\nconst WebSocket = global.WebSocket || require(\"ws\");\n/**\n * WebSocket transport implementation\n */\n\n\nclass WebSocketTransport extends Transport {\n  // this transport is not discoverable\n  static async open(url) {\n    const exchangeMethods = await new Promise((resolve, reject) => {\n      try {\n        const socket = new WebSocket(url);\n        const exchangeMethods = {\n          resolveExchange: _b => {},\n          rejectExchange: _e => {},\n          onDisconnect: () => {},\n          close: () => socket.close(),\n          send: msg => socket.send(msg)\n        };\n\n        socket.onopen = () => {\n          socket.send(\"open\");\n        };\n\n        socket.onerror = e => {\n          exchangeMethods.onDisconnect();\n          reject(e);\n        };\n\n        socket.onclose = () => {\n          exchangeMethods.onDisconnect();\n          reject(new TransportError(\"OpenFailed\", \"OpenFailed\"));\n        };\n\n        socket.onmessage = e => {\n          if (typeof e.data !== \"string\") return;\n          const data = JSON.parse(e.data);\n\n          switch (data.type) {\n            case \"opened\":\n              return resolve(exchangeMethods);\n\n            case \"error\":\n              reject(new Error(data.error));\n              return exchangeMethods.rejectExchange(new TransportError(data.error, \"WSError\"));\n\n            case \"response\":\n              return exchangeMethods.resolveExchange(Buffer.from(data.data, \"hex\"));\n          }\n        };\n      } catch (e) {\n        reject(e);\n      }\n    });\n    return new WebSocketTransport(exchangeMethods);\n  }\n\n  constructor(hook) {\n    super();\n    this.hook = void 0;\n    this.hook = hook;\n\n    hook.onDisconnect = () => {\n      this.emit(\"disconnect\");\n      this.hook.rejectExchange(new TransportError(\"WebSocket disconnected\", \"WSDisconnect\"));\n    };\n  }\n\n  async exchange(apdu) {\n    const hex = apdu.toString(\"hex\");\n    log(\"apdu\", \"=> \" + hex);\n    const res = await new Promise((resolve, reject) => {\n      this.hook.rejectExchange = e => reject(e);\n\n      this.hook.resolveExchange = b => resolve(b);\n\n      this.hook.send(hex);\n    });\n    log(\"apdu\", \"<= \" + res.toString(\"hex\"));\n    return res;\n  }\n\n  setScrambleKey() {}\n\n  async close() {\n    this.hook.close();\n    return new Promise(success => {\n      setTimeout(success, 200);\n    });\n  }\n\n}\n\nWebSocketTransport.isSupported = () => Promise.resolve(typeof WebSocket === \"function\");\n\nWebSocketTransport.list = () => Promise.resolve([]);\n\nWebSocketTransport.listen = _observer => ({\n  unsubscribe: () => {}\n});\n\nWebSocketTransport.check = async (url, timeout = 5000) => new Promise((resolve, reject) => {\n  const socket = new WebSocket(url);\n  let success = false;\n  setTimeout(() => {\n    socket.close();\n  }, timeout);\n\n  socket.onopen = () => {\n    success = true;\n    socket.close();\n  };\n\n  socket.onclose = () => {\n    if (success) resolve();else {\n      reject(new TransportError(\"failed to access WebSocketTransport(\" + url + \")\", \"WebSocketTransportNotAccessible\"));\n    }\n  };\n\n  socket.onerror = () => {\n    reject(new TransportError(\"failed to access WebSocketTransport(\" + url + \"): error\", \"WebSocketTransportNotAccessible\"));\n  };\n});\n\nconst getTransport = url => !url.startsWith(\"ws\") ? HttpTransport : WebSocketTransport;\n\nconst inferURLs = async urls => {\n  const r = await (typeof urls === \"function\" ? urls() : urls);\n  return typeof r === \"string\" ? [r] : r;\n};\n\nvar withStaticURLs = (urls => {\n  class StaticTransport extends Transport {}\n\n  StaticTransport.isSupported = HttpTransport.isSupported;\n\n  StaticTransport.list = () => inferURLs(urls).then(urls => Promise.all(urls.map(url => getTransport(url).check(url).then(() => [url]).catch(() => [])))).then(arrs => arrs.reduce((acc, a) => acc.concat(a), []));\n\n  StaticTransport.listen = observer => {\n    let unsubscribed = false;\n    const seen = {};\n\n    function checkLoop() {\n      if (unsubscribed) return;\n      inferURLs(urls).then(urls => Promise.all(urls.map(async url => {\n        if (unsubscribed) return;\n\n        try {\n          await getTransport(url).check(url);\n          if (unsubscribed) return;\n\n          if (!seen[url]) {\n            seen[url] = 1;\n            observer.next({\n              type: \"add\",\n              descriptor: url\n            });\n          }\n        } catch (e) {\n          // nothing\n          if (seen[url]) {\n            delete seen[url];\n            observer.next({\n              type: \"remove\",\n              descriptor: url\n            });\n          }\n        }\n      }))).then(() => new Promise(success => setTimeout(success, 5000))).then(checkLoop);\n    }\n\n    checkLoop();\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      }\n    };\n  };\n\n  StaticTransport.open = url => getTransport(url).open(url);\n\n  return StaticTransport;\n});\n\nexport default withStaticURLs;\n//# sourceMappingURL=lazy-chunk-withStaticURLs.es.js.map\n","'use strict';\n\nmodule.exports = function() {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n"],"sourceRoot":""}