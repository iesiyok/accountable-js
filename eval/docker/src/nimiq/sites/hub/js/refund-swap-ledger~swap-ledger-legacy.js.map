{"version":3,"sources":["sources://./src/lib/LedgerSwapProxy.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwG;AAClD;AAC1B;AACU;AACe;AAE9C,MAAM,qBAAqB,GAAG;IACjC,2FAA2F;IAC3F,IAAI,EAAG,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IAClF,6FAA6F;IAC7F,MAAM,EAAE,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;CACtF,CAAC;AAEF,MAAM,kCAAkC,GAAG,wBAAwB,CAAC;AAEpE;;;;;;;;;GASG;AACY,MAAM,eAAe;IA4KhC,YACoB,OAAsB,EACrB,wBAAgC,EACjD,eAAgD,EACxC,sBAA8C,EACrC,cAAsB,EACtB,YAAqB;QALtB,YAAO,GAAP,OAAO,CAAe;QACrB,6BAAwB,GAAxB,wBAAwB,CAAQ;QAEzC,2BAAsB,GAAtB,sBAAsB,CAAwB;QACrC,mBAAc,GAAd,cAAc,CAAQ;QACtB,iBAAY,GAAZ,YAAY,CAAS;QAEtC,IAAI,eAAe,YAAY,KAAK,CAAC,OAAO,EAAE;YAC1C,IAAI,CAAC,qBAAqB,GAAG,eAAe,CAAC,SAAS,CAAC;YACvD,IAAI,CAAC,sBAAsB,GAAG,eAAe,CAAC,UAAU,CAAC;SAC5D;aAAM;YACH,IAAI,CAAC,qBAAqB,GAAG,eAAe,CAAC;YAC7C,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;SACtC;IACL,CAAC;IA1LM,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,uBAA+B,EAAE,aAAqB,EAAE,WAAoB;QAEnG,MAAM,cAAc,GAAG,MAAM,eAAe,CAAC,6BAA6B,CACtE,uBAAuB,EACvB,aAAa,EACb,WAAW,CACd,CAAC;QACF,MAAM,qBAAqB,GAAG,MAAM,yDAAS,CAAC,KAAK,CAAC,YAAY,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QAC7F,MAAM,YAAY,GAAG,eAAe,CAAC,uBAAuB,CAAC,cAAc,CAAC,SAAS,EAAE,qBAAqB,CAAC,CAAC;QAC9G,OAAO,IAAI,eAAe,CAAC,YAAY,EAAE,uBAAuB,EAAE,cAAc,EAC5E,qBAAqB,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;IAC3D,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC,YAA2B,EAAE,aAAqB,EAAE,WAAoB;QAExG,oGAAoG;QACpG,MAAM,wBAAwB,GAAG,MAAM,eAAe,CAAC,wBAAwB,CAAC,YAAY,CAAC,CAAC;QAC9F,MAAM,mBAAmB,GAAG,wBAAwB,CAAC,mBAAmB,CAAC,CAAC,qCAAqC;QAE/G,IAAI,YAA2B,CAAC;QAChC,IAAI,4BAA4B,GAA2B,IAAI,CAAC;QAChE,IAAI,wBAAwB,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,EAAE;YACnG,kFAAkF;YAClF,YAAY,GAAG,YAAY,CAAC;YAC5B,4BAA4B,GAAG,eAAe,CAAC,gCAAgC,CAC3E,wBAAwB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SAC1C;aAAM;YACH,+DAA+D;YAC/D,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC;SACzE;QAED,+BAA+B;QAE/B,8EAA8E;QAC9E,MAAM,cAAc,GAAG,MAAM,eAAe,CAAC,6BAA6B,CACtE,mBAAmB,EACnB,aAAa,EACb,WAAW,CACd,CAAC;QACF,MAAM,qBAAqB,GAAG,MAAM,yDAAS,CAAC,KAAK,CAAC,YAAY,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QAC7F,IAAI,eAAe,CAAC,uBAAuB,CAAC,cAAc,CAAC,SAAS,EAAE,qBAAqB,CAAC;aACvF,MAAM,CAAC,YAAY,CAAC,EAAE;YACvB,OAAO,IAAI,eAAe,CAAC,YAAY,EAAE,mBAAmB,EAAE,cAAc,EACxE,qBAAqB,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;SAC1D;QAED,4GAA4G;QAC5G,iGAAiG;QACjG,IAAI,CAAC,4BAA4B;eAC1B,CAAC,wBAAwB,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,EAAE;YACvG,uGAAuG;YACvG,4GAA4G;YAC5G,oDAAoD;YACpD,MAAM,uBAAuB,GAAG,MAAM,eAAe,CAAC,wBAAwB,CAAC,YAAY,CAAC,CAAC;YAC7F,4BAA4B,GAAG,eAAe,CAAC,gCAAgC,CAC3E,uBAAuB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACzC;QACD,IAAI,4BAA4B;eACzB,eAAe,CAAC,uBAAuB,CAAC,4BAA4B,EAAE,qBAAqB,CAAC;iBAC1F,MAAM,CAAC,YAAY,CAAC,EAAE;YAC3B,yGAAyG;YACzG,0FAA0F;YAC1F,OAAO,IAAI,eAAe,CAAC,YAAY,EAAE,mBAAmB,EAAE,4BAA4B,EACtF,qBAAqB,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;SAC1D;QAED,4BAA4B;QAC5B,MAAM,eAAe,GAAG,MAAM,eAAe,CAAC,sBAAsB,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QACjG,IAAI,eAAe,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE;YAC5D,OAAO,IAAI,eAAe,CAAC,YAAY,EAAE,mBAAmB,EAAE,eAAe;YACzE,2BAA2B,CAAC,IAAI,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;SACrE;QAED,yBAAyB;QACzB,MAAM,IAAI,KAAK,CAAC,8CAA8C,YAAY,CAAC,qBAAqB,EAAE,GAAG,CAAC,CAAC;IAC3G,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,6BAA6B,CAC9C,uBAA+B,EAC/B,aAAqB,EACrB,WAAoB;QAEpB,MAAM,EAAE,YAAY,EAAE,kBAAkB,EAAE,GAAG,wEAAc,CAAC,aAAa,CAAC,CAAC;QAC3E,MAAM,0BAA0B,GAAG,sEAAY,CAAC;YAC5C,IAAI,EAAE,sDAAI,CAAC,KAAK;YAChB,yGAAyG;YACzG,wGAAwG;YACxG,YAAY,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,uBAAuB;YACnD,YAAY,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,kBAAkB;SACjD,CAAC,CAAC;QACH,MAAM,CAAC,sBAAsB,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YAC/C,yDAAS,CAAC,KAAK,CAAC,YAAY,CAAC,0BAA0B,EAAE,WAAW,CAAC;YACrE,0DAAS,EAAE;SACd,CAAC,CAAC;QAEH,IAAI,CAAC,YAAY,CAAC,kCAAkC,CAAC,EAAE;YACnD,iCAAiC;YACjC,YAAY,CAAC,kCAAkC,CAAC,GAAG,KAAK,CAAC,WAAW,CAAC,QAAQ,CACzE,KAAK,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,SAAS,EAAE,CAAC,CAAC;SAChD;QACD,IAAI,IAAgB,CAAC;QACrB,IAAI;YACA,IAAI,GAAG,KAAK,CAAC,WAAW,CAAC,UAAU,CAC/B,YAAY,CAAC,kCAAkC,CAAC,EAChD,KAAK,CAAC,UAAU,CAAC,IAAI,CACxB,CAAC;SACL;QAAC,OAAO,CAAC,EAAE;YACR,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;SACvF;QAED,MAAM,mBAAmB,GAAG,IAAI,UAAU,CAAC,sBAAsB,CAAC,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;QAChG,mBAAmB,CAAC,GAAG,CAAC,sBAAsB,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC;QAC/D,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,sBAAsB,CAAC,cAAc,CAAC,CAAC;QACrE,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,mBAAmB,CAAC,CAAC;QACpE,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC;IACpE,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,sBAAsB,CAAC,aAAqB,EAAE,WAAoB;QACnF,MAAM,EAAE,YAAY,EAAE,kBAAkB,EAAE,GAAG,wEAAc,CAAC,aAAa,CAAC,CAAC;QAC3E,MAAM,0BAA0B,GAAG,sEAAY,CAAC;YAC5C,IAAI,EAAE,sDAAI,CAAC,KAAK;YAChB,YAAY,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC;YACzB,YAAY,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,kBAAkB;SACjD,CAAC,CAAC;QACH,MAAM,CAAC,sBAAsB,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YAC/C,yDAAS,CAAC,KAAK,CAAC,YAAY,CAAC,0BAA0B,EAAE,WAAW,CAAC;YACrE,0DAAS,EAAE;SACd,CAAC,CAAC;QAEH,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,sBAAsB,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;IAC1F,CAAC;IAEO,MAAM,CAAC,uBAAuB,CAClC,oBAAqC,EACrC,qBAAsC;QAEtC,6GAA6G;QAC7G,0CAA0C;QAC1C,MAAM,UAAU,GAAG,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9F,oEAAe,EAAE,CAAC;QAClB,MAAM,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAC5D,OAAO,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IAC9C,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,kBAAiC;QAE3E,IAAI,CAAC,mEAAa,CAAC,WAAW,EAAE,EAAE;YAC9B,mEAAa,CAAC,cAAc,CAAC,8CAAM,CAAC,eAAe,CAAC,CAAC;SACxD;QACD,MAAM,aAAa,GAAG,mEAAa,CAAC,QAAQ,CAAC;QAC7C,MAAM,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,sCAAsC;QAElE,6GAA6G;QAC7G,yGAAyG;QACzG,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,qBAAqB,EAAE,CAAC;QACvE,MAAM,kBAAkB,GAAG,MAAM,aAAa,CAAC,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;QAC7F,IAAI,CAAC,kBAAkB,CAAC,MAAM;YAAE,MAAM,IAAI,KAAK,CAAC,yCAAyC,mBAAmB,EAAE,CAAC,CAAC;QAChH,OAAO,kBAAkB,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC7D,CAAC;IAEO,MAAM,CAAC,gCAAgC,CAAC,mBAA2B;QACvE,MAAM,qBAAqB,GAAG,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,eAAe;QAC7G,IAAI,mBAAmB,CAAC,MAAM,KAAK,qBAAqB;eACjD,CAAC,mBAAmB,CAAC,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;YAAE,OAAO,IAAI,CAAC;QACzG,OAAO,IAAI,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,CAChD,mBAAmB,CAAC,SAAS,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,CAAC;IAsBD,IAAW,cAAc;QACrB,OAAO,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC;IACzC,CAAC;IAEM,cAAc;QAIjB,OAAO;YACH,SAAS,EAAE,IAAI,CAAC,OAAO;YACvB,aAAa,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK;YACvC,mBAAmB,EAAE,IAAI,CAAC,wBAAwB;YAClD,SAAS,EAAE,IAAI,CAAC,sBAAsB;gBAClC,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,GAAG,qBAAqB,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,CAAC,CAAC;gBAC5F,CAAC,CAAC,qBAAqB,CAAC,IAAI;SACnC,CAAC;IACN,CAAC;IAEM,mBAAmB,CAAC,QAAoB;QAI3C,MAAM,iBAAiB,GAAG,KAAK,CAAC,wBAAwB,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC/E,IAAI,CAAC,CAAC,QAAQ,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YAC3G,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;SACtE;QACD,OAAO;YACH,MAAM,EAAE,IAAI,CAAC,OAAO;YACpB,UAAU,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK;YACpC,SAAS,EAAE,KAAK,CAAC,OAAO,CAAC,iBAAiB;YAC1C,aAAa,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI;YACtC,mBAAmB,EAAE,IAAI,CAAC,wBAAwB;YAClD,KAAK,EAAE,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB;YAC/C,SAAS,EAAE,QAAQ;SACtB,CAAC;IACN,CAAC;IAEM,aAAa,CAAC,YAA2B;QAI5C,IAAI,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACnC,uBAAuB;YACvB,OAAO;gBACH,MAAM,EAAE,YAAY;gBACpB,UAAU,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK;gBACpC,SAAS,EAAE,qBAAqB,CAAC,MAAM;aAC1C,CAAC;SACL;aAAM;YACH,sBAAsB;YACtB,OAAO;gBACH,MAAM,EAAE,YAAY;gBACpB,UAAU,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI;aACtC,CAAC;SACL;IACL,CAAC;IAEM,KAAK,CAAC,eAAe,CAAC,EACzB,MAAM,EACN,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EACrC,SAAS,EACT,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EACxC,KAAK,EACL,GAAG,GAAG,CAAC,EACP,mBAAmB,EACnB,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EACnC,SAAS,EACT,OAAO,GACY;QACnB,MAAM,0DAAS,EAAE,CAAC;QAElB,gHAAgH;QAChH,gGAAgG;QAChG,MAAM,WAAW,GAAG,IAAI,KAAK,CAAC,mBAAmB,CAC7C,MAAM,EACN,UAAU,EACV,SAAS,EACT,aAAa,EACb,KAAK,EACL,GAAG,EACH,mBAAmB,EACnB,KAAK,EACL,SAAS,IAAI,IAAI,UAAU,CAAC,CAAC,CAAC,EAC9B,SAAS,EACT,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,aAAa,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CACxE,CAAC;QAEF,IAAI,IAAI,CAAC,sBAAsB,EAAE;YAC7B,MAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CACpC,IAAI,CAAC,sBAAsB,EAC3B,IAAI,CAAC,qBAAqB,EAC1B,WAAW,CAAC,gBAAgB,EAAE,CACjC,CAAC;YACF,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC,SAAS,EAAE,CAAC;SACpG;aAAM;YACH,kCAAkC;YAClC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,sBAAsB;gBACrD,+BAA+B;mBAC5B,MAAM,yDAAS,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;YAClF,IAAI,WAAW,CAAC,UAAU,KAAK,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK;mBAChD,WAAW,CAAC,aAAa,KAAK,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE;gBAC3D,MAAM,IAAI,KAAK,CAAC,kEAAkE,CAAC,CAAC;aACvF;YACD,MAAM,EAAE,SAAS,EAAE,GAAG,KAAK,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,KAAK,CAAC,YAAY,CACzE,CAAC,MAAM,yDAAS,CAAC,KAAK,CAAC,eAAe,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CACrG,CAAC,CAAC;YACH,WAAW,CAAC,KAAK,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,sBAAuB,EAAE,SAAS,CAAC,CAAC,SAAS,EAAE,CAAC;SACtG;QAED,OAAO,WAAW,CAAC;IACvB,CAAC;IAEM,oBAAoB,CAAC,MAAuB,EAAE,SAA0B;QAC3E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,EAAE;YAC3F,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;QACD,IAAI,CAAC,IAAI,CAAC,sBAAsB,EAAE;YAC9B,OAAO,KAAK,CAAC,cAAc,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;SAC5D;aAAM;YACH,oCAAoC;YACpC,MAAM,UAAU,GAAG,CAAC,IAAI,CAAC,qBAAqB,EAAE,IAAI,CAAC,sBAAuB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3G,OAAO,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC;SACvE;IACL,CAAC;CACJ","file":"js/refund-swap-ledger~swap-ledger-legacy.js","sourcesContent":["import LedgerApi, { Coin, TransactionInfoNimiq, getBip32Path, parseBip32Path } from '@nimiq/ledger-api';\nimport { NetworkClient } from '@nimiq/network-client';\nimport Config from 'config';\nimport { loadNimiq } from './Helpers';\nimport patchMerkleTree from '../lib/MerkleTreePatch';\n\nexport const LedgerSwapProxyMarker = {\n    // HTLC Proxy Funding, abbreviated as 'HPFD', mapped to values outside of basic ascii range\n    FUND:  new Uint8Array([0, ...('HPFD'.split('').map((c) => c.charCodeAt(0) + 63))]),\n    // HTLC Proxy Redeeming, abbreviated as 'HPRD', mapped to values outside of basic ascii range\n    REDEEM: new Uint8Array([0, ...('HPRD'.split('').map((c) => c.charCodeAt(0) + 63))]),\n};\n\nconst LEDGER_SWAP_PROXY_SALT_STORAGE_KEY = 'ledger-swap-proxy-salt';\n\n/**\n * As the Nimiq Ledger app is not able to sign HTLC transactions yet, we currently use a temporary in-memory key for\n * creating, redeeming and refunding HTLCs. The proxy is designed as follows:\n * - It uses data derived from the ledger key to make access to the Ledger key mandatory for accessing the funds.\n * - To create a unique proxy for each swap, the validity start height of the Nimiq swap transaction is factored in.\n * - As only public data can be fetched from the Ledger, we salt the data with a locally stored random secret.\n * - To avoid loss of funds if the random secret gets lost, the proxy is a multi-signature address with the Ledger\n *   as a backup signer, such that the proxy can be redeemed via the Ledger directly and once the Ledger app\n *   supports HTLC transactions, the HTLC too.\n */\nexport default class LedgerSwapProxy {\n    public static async create(swapValidityStartHeight: number, ledgerKeyPath: string, ledgerKeyId?: string)\n        : Promise<LedgerSwapProxy> {\n        const localSignerKey = await LedgerSwapProxy._createLocalMultiSigSignerKey(\n            swapValidityStartHeight,\n            ledgerKeyPath,\n            ledgerKeyId,\n        );\n        const ledgerSignerPublicKey = await LedgerApi.Nimiq.getPublicKey(ledgerKeyPath, ledgerKeyId);\n        const proxyAddress = LedgerSwapProxy._computeMultiSigAddress(localSignerKey.publicKey, ledgerSignerPublicKey);\n        return new LedgerSwapProxy(proxyAddress, swapValidityStartHeight, localSignerKey,\n            ledgerSignerPublicKey, ledgerKeyPath, ledgerKeyId);\n    }\n\n    public static async createForRefund(refundSender: Nimiq.Address, ledgerKeyPath: string, ledgerKeyId?: string)\n        : Promise<LedgerSwapProxy> {\n        // Check if the refund sender is the htlc or the proxy and determine the swap validity start height.\n        const senderFundingTransaction = await LedgerSwapProxy._fetchFundingTransaction(refundSender);\n        const validityStartHeight = senderFundingTransaction.validityStartHeight; // same for proxy and htlc funding tx\n\n        let proxyAddress: Nimiq.Address;\n        let originalLocalSignerPublicKey: Nimiq.PublicKey | null = null;\n        if (senderFundingTransaction.data.raw.startsWith(Nimiq.BufferUtils.toHex(LedgerSwapProxyMarker.FUND))) {\n            // The refund sender got funded by a proxy funding transaction, thus is the proxy.\n            proxyAddress = refundSender;\n            originalLocalSignerPublicKey = LedgerSwapProxy._getOriginalLocalSignerPublicKey(\n                senderFundingTransaction.data.raw);\n        } else {\n            // The refund sender is the HTLC which got funded by the proxy.\n            proxyAddress = Nimiq.Address.fromAny(senderFundingTransaction.sender);\n        }\n\n        // Find the correct signer key.\n\n        // First check the multisig signer key derived from the Ledger and local salt.\n        const localSignerKey = await LedgerSwapProxy._createLocalMultiSigSignerKey(\n            validityStartHeight,\n            ledgerKeyPath,\n            ledgerKeyId,\n        );\n        const ledgerSignerPublicKey = await LedgerApi.Nimiq.getPublicKey(ledgerKeyPath, ledgerKeyId);\n        if (LedgerSwapProxy._computeMultiSigAddress(localSignerKey.publicKey, ledgerSignerPublicKey)\n            .equals(proxyAddress)) {\n            return new LedgerSwapProxy(proxyAddress, validityStartHeight, localSignerKey,\n                ledgerSignerPublicKey, ledgerKeyPath, ledgerKeyId);\n        }\n\n        // Do we have the wrong local signer key due to a different salt because it got lost or we're on a different\n        // browser? Try to get the original local signer public key from the transaction history instead.\n        if (!originalLocalSignerPublicKey\n            && !senderFundingTransaction.data.raw.startsWith(Nimiq.BufferUtils.toHex(LedgerSwapProxyMarker.FUND))) {\n            // We don't have the originalLocalSignerPublicKey yet and didn't already check for it above because the\n            // senderFundingTransaction funds the HTLC and not the proxy. Fetch the proxy funding transaction and try to\n            // extract the originalLocalSignerPublicKey from it.\n            const proxyFundingTransaction = await LedgerSwapProxy._fetchFundingTransaction(proxyAddress);\n            originalLocalSignerPublicKey = LedgerSwapProxy._getOriginalLocalSignerPublicKey(\n                proxyFundingTransaction.data.raw);\n        }\n        if (originalLocalSignerPublicKey\n            && LedgerSwapProxy._computeMultiSigAddress(originalLocalSignerPublicKey, ledgerSignerPublicKey)\n                .equals(proxyAddress)) {\n            // Note that this LedgerSwapProxy is not able to sign transactions locally, as the correct localSignerKey\n            // is unknown. Transactions have to be signed with the Ledger as secondary signer instead.\n            return new LedgerSwapProxy(proxyAddress, validityStartHeight, originalLocalSignerPublicKey,\n                ledgerSignerPublicKey, ledgerKeyPath, ledgerKeyId);\n        }\n\n        // Try the legacy proxy key.\n        const legacySignerKey = await LedgerSwapProxy._createLegacySignerKey(ledgerKeyPath, ledgerKeyId);\n        if (legacySignerKey.publicKey.toAddress().equals(proxyAddress)) {\n            return new LedgerSwapProxy(proxyAddress, validityStartHeight, legacySignerKey,\n                /* ledgerSignerPublicKey */ null, ledgerKeyPath, ledgerKeyId);\n        }\n\n        // Unknown refund sender.\n        throw new Error(`Proxy signer key missing for refund sender ${refundSender.toUserFriendlyAddress()}.`);\n    }\n\n    private static async _createLocalMultiSigSignerKey(\n        swapValidityStartHeight: number,\n        ledgerKeyPath: string,\n        ledgerKeyId?: string,\n    ): Promise<Nimiq.KeyPair> {\n        const { addressIndex: ledgerAddressIndex } = parseBip32Path(ledgerKeyPath);\n        const entropySourcePublicKeyPath = getBip32Path({\n            coin: Coin.NIMIQ,\n            // Create a unique proxy per swap by factoring in the validity start height of the Nimiq swap transaction\n            // and the address index of the proxy owning Ledger address. Go from the maximum index allowed by bip32.\n            accountIndex: 2 ** 31 - 1 - swapValidityStartHeight,\n            addressIndex: 2 ** 31 - 1 - ledgerAddressIndex,\n        });\n        const [entropySourcePublicKey] = await Promise.all([\n            LedgerApi.Nimiq.getPublicKey(entropySourcePublicKeyPath, ledgerKeyId),\n            loadNimiq(),\n        ]);\n\n        if (!localStorage[LEDGER_SWAP_PROXY_SALT_STORAGE_KEY]) {\n            // generate a 32 byte random salt\n            localStorage[LEDGER_SWAP_PROXY_SALT_STORAGE_KEY] = Nimiq.BufferUtils.toBase64(\n                Nimiq.PrivateKey.generate().serialize());\n        }\n        let salt: Uint8Array;\n        try {\n            salt = Nimiq.BufferUtils.fromBase64(\n                localStorage[LEDGER_SWAP_PROXY_SALT_STORAGE_KEY],\n                Nimiq.PrivateKey.SIZE,\n            );\n        } catch (e) {\n            throw new Error(`Failed to read random salt from local storage: ${e.message || e}`);\n        }\n\n        const saltedEntropySource = new Uint8Array(entropySourcePublicKey.serializedSize + salt.length);\n        saltedEntropySource.set(entropySourcePublicKey.serialize(), 0);\n        saltedEntropySource.set(salt, entropySourcePublicKey.serializedSize);\n        const proxyEntropy = Nimiq.Hash.computeBlake2b(saltedEntropySource);\n        return Nimiq.KeyPair.derive(new Nimiq.PrivateKey(proxyEntropy));\n    }\n\n    private static async _createLegacySignerKey(ledgerKeyPath: string, ledgerKeyId?: string): Promise<Nimiq.KeyPair> {\n        const { addressIndex: ledgerAddressIndex } = parseBip32Path(ledgerKeyPath);\n        const entropySourcePublicKeyPath = getBip32Path({\n            coin: Coin.NIMIQ,\n            accountIndex: 2 ** 31 - 1, // max index allowed by bip32\n            addressIndex: 2 ** 31 - 1 - ledgerAddressIndex, // use a distinct proxy per address for improved privacy\n        });\n        const [entropySourcePublicKey] = await Promise.all([\n            LedgerApi.Nimiq.getPublicKey(entropySourcePublicKeyPath, ledgerKeyId),\n            loadNimiq(),\n        ]);\n\n        return Nimiq.KeyPair.derive(new Nimiq.PrivateKey(entropySourcePublicKey.serialize()));\n    }\n\n    private static _computeMultiSigAddress(\n        localSignerPublicKey: Nimiq.PublicKey,\n        ledgerSignerPublicKey: Nimiq.PublicKey,\n    ): Nimiq.Address {\n        // See MultiSigWallet in core-js. Note that we don't have to aggregate the public keys as it's a 1 of 2 multi\n        // sig, where a single signature suffices.\n        const publicKeys = [localSignerPublicKey, ledgerSignerPublicKey].sort((a, b) => a.compare(b));\n        patchMerkleTree();\n        const merkleRoot = Nimiq.MerkleTree.computeRoot(publicKeys);\n        return Nimiq.Address.fromHash(merkleRoot);\n    }\n\n    private static async _fetchFundingTransaction(htlcOrProxyAddress: Nimiq.Address)\n        : Promise<ReturnType<Nimiq.Client.TransactionDetails['toPlain']>> {\n        if (!NetworkClient.hasInstance()) {\n            NetworkClient.createInstance(Config.networkEndpoint);\n        }\n        const networkClient = NetworkClient.Instance;\n        await networkClient.init(); // Make sure the client is initialized\n\n        // Get the oldest transaction as funding transaction. Note that non-legacy swap proxies are swap specific and\n        // not reused, therefore the fetched transaction history should be small unless it's a legacy swap proxy.\n        const userFriendlyAddress = htlcOrProxyAddress.toUserFriendlyAddress();\n        const transactionHistory = await networkClient.getTransactionsByAddress(userFriendlyAddress);\n        if (!transactionHistory.length) throw new Error(`Failed to get transaction history for ${userFriendlyAddress}`);\n        return transactionHistory[transactionHistory.length - 1];\n    }\n\n    private static _getOriginalLocalSignerPublicKey(proxyFundingDataHex: string): Nimiq.PublicKey | null {\n        const expectedDataHexLength = (LedgerSwapProxyMarker.FUND.length + Nimiq.PublicKey.SIZE) * 2; //  * 2 for hex\n        if (proxyFundingDataHex.length !== expectedDataHexLength\n            || !proxyFundingDataHex.startsWith(Nimiq.BufferUtils.toHex(LedgerSwapProxyMarker.FUND))) return null;\n        return new Nimiq.PublicKey(Nimiq.BufferUtils.fromHex(\n            proxyFundingDataHex.substring(LedgerSwapProxyMarker.FUND.length * 2)));\n    }\n\n    private readonly _localSignerPublicKey: Nimiq.PublicKey;\n    private readonly _localSignerPrivateKey: Nimiq.PrivateKey | null;\n\n    private constructor(\n        public readonly address: Nimiq.Address,\n        private readonly _swapValidityStartHeight: number,\n        _localSignerKey: Nimiq.KeyPair | Nimiq.PublicKey,\n        private _ledgerSignerPublicKey: Nimiq.PublicKey | null,\n        private readonly _ledgerKeyPath: string,\n        private readonly _ledgerKeyId?: string,\n    ) {\n        if (_localSignerKey instanceof Nimiq.KeyPair) {\n            this._localSignerPublicKey = _localSignerKey.publicKey;\n            this._localSignerPrivateKey = _localSignerKey.privateKey;\n        } else {\n            this._localSignerPublicKey = _localSignerKey;\n            this._localSignerPrivateKey = null;\n        }\n    }\n\n    public get canSignLocally(): boolean {\n        return !!this._localSignerPrivateKey;\n    }\n\n    public getFundingInfo(): Pick<\n        TransactionInfoNimiq,\n        'recipient' | 'recipientType' | 'validityStartHeight' | 'extraData'\n    > {\n        return {\n            recipient: this.address,\n            recipientType: Nimiq.Account.Type.BASIC,\n            validityStartHeight: this._swapValidityStartHeight,\n            extraData: this._ledgerSignerPublicKey\n                ? new Uint8Array([...LedgerSwapProxyMarker.FUND, ...this._localSignerPublicKey.serialize()])\n                : LedgerSwapProxyMarker.FUND, // legacy proxy\n        };\n    }\n\n    public getHtlcCreationInfo(htlcData: Uint8Array): Pick<\n        TransactionInfoNimiq,\n        'sender' | 'senderType' | 'recipient' | 'recipientType' | 'validityStartHeight' | 'flags' | 'extraData'\n    > {\n        const decodedHtlcScript = Nimiq.HashedTimeLockedContract.dataToPlain(htlcData);\n        if (!('sender' in decodedHtlcScript) || !Nimiq.Address.fromAny(decodedHtlcScript.sender).equals(this.address)) {\n            throw new Error('The HTLC refund address must be the swap proxy.');\n        }\n        return {\n            sender: this.address,\n            senderType: Nimiq.Account.Type.BASIC,\n            recipient: Nimiq.Address.CONTRACT_CREATION,\n            recipientType: Nimiq.Account.Type.HTLC,\n            validityStartHeight: this._swapValidityStartHeight,\n            flags: Nimiq.Transaction.Flag.CONTRACT_CREATION,\n            extraData: htlcData,\n        };\n    }\n\n    public getRefundInfo(refundSender: Nimiq.Address): Pick<\n        TransactionInfoNimiq,\n        'sender' | 'senderType' | 'extraData'\n    > {\n        if (refundSender.equals(this.address)) {\n            // refunding from proxy\n            return {\n                sender: refundSender,\n                senderType: Nimiq.Account.Type.BASIC,\n                extraData: LedgerSwapProxyMarker.REDEEM,\n            };\n        } else {\n            // refunding from htlc\n            return {\n                sender: refundSender,\n                senderType: Nimiq.Account.Type.HTLC,\n            };\n        }\n    }\n\n    public async signTransaction({\n        sender,\n        senderType = Nimiq.Account.Type.BASIC,\n        recipient,\n        recipientType = Nimiq.Account.Type.BASIC,\n        value,\n        fee = 0,\n        validityStartHeight,\n        flags = Nimiq.Transaction.Flag.NONE,\n        extraData,\n        network,\n    }: TransactionInfoNimiq): Promise<Nimiq.Transaction> {\n        await loadNimiq();\n\n        // Always create an ExtendedTransaction because all transactions that will typically be signed by the proxy will\n        // be ExtendedTransactions because they include extraData or have sender- or recipientType HTLC.\n        const transaction = new Nimiq.ExtendedTransaction(\n            sender,\n            senderType,\n            recipient,\n            recipientType,\n            value,\n            fee,\n            validityStartHeight,\n            flags,\n            extraData || new Uint8Array(0),\n            undefined,\n            network ? Nimiq.GenesisConfig.CONFIGS[network].NETWORK_ID : undefined,\n        );\n\n        if (this._localSignerPrivateKey) {\n            const signature = Nimiq.Signature.create(\n                this._localSignerPrivateKey,\n                this._localSignerPublicKey,\n                transaction.serializeContent(),\n            );\n            transaction.proof = this.createSignatureProof(this._localSignerPublicKey, signature).serialize();\n        } else {\n            // Sign with the Ledger as backup.\n            this._ledgerSignerPublicKey = this._ledgerSignerPublicKey\n                // should never actually happen\n                || await LedgerApi.Nimiq.getPublicKey(this._ledgerKeyPath, this._ledgerKeyId);\n            if (transaction.senderType !== Nimiq.Account.Type.BASIC\n                || transaction.recipientType !== Nimiq.Account.Type.BASIC) {\n                throw new Error('Contract transactions can currently not be signed by the Ledger.');\n            }\n            const { signature } = Nimiq.SignatureProof.unserialize(new Nimiq.SerialBuffer(\n                (await LedgerApi.Nimiq.signTransaction(transaction, this._ledgerKeyPath, this._ledgerKeyId)).proof,\n            ));\n            transaction.proof = this.createSignatureProof(this._ledgerSignerPublicKey!, signature).serialize();\n        }\n\n        return transaction;\n    }\n\n    public createSignatureProof(signer: Nimiq.PublicKey, signature: Nimiq.Signature): Nimiq.SignatureProof {\n        if (!signer.equals(this._localSignerPublicKey) && !signer.equals(this._ledgerSignerPublicKey)) {\n            throw new Error('Invalid proxy signer.');\n        }\n        if (!this._ledgerSignerPublicKey) {\n            return Nimiq.SignatureProof.singleSig(signer, signature);\n        } else {\n            // Create a multisig SignatureProof.\n            const publicKeys = [this._localSignerPublicKey, this._ledgerSignerPublicKey!].sort((a, b) => a.compare(b));\n            return Nimiq.SignatureProof.multiSig(signer, publicKeys, signature);\n        }\n    }\n}\n"],"sourceRoot":""}