{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-bitcoin.es.js","sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAA0D;AACkD;;AAE5G,6BAA6B,2DAAO;AACpC;AACA;AACA,oBAAoB,sDAAI;AACxB,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,kDAAkD,kNAA6C,EAAE,0NAAiD,EAAE,uOAAmC,wBAAwB,YAAY,EAAE;AAC7N,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB,yDAAO,wBAAwB;AACzE;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,eAAe,YAAY,gCAAgC,sEAAY;AACvE,kBAAkB,sDAAI;AACtB,yBAAyB,oEAAkB;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,kNAA6C,EAAE,0NAAiD,EAAE,uOAAmC,wBAAwB,YAAY,EAAE;AACxM;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8DAA8D,eAAe;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,0NAAiD,EAAE,8PAAkC,EAAE,oQAAkD,EAAE,2RAAmC,EAAE,sOAAmC,EAAE,8LAAmC,EAAE,kNAA6C,EAAE,uOAAmC,EAAE,yUAAgC;AACzY;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8DAA8D,eAAe;AACvH;AACA;AACA;AACA;AACA,0BAA0B,0NAAiD,EAAE,uOAAmC,EAAE,2RAAmC,EAAE,kNAA6C,EAAE,oQAAkD,EAAE,8LAAmC,EAAE,qSAAwC;AACvU;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8DAA8D,eAAe;AACvH;AACA;AACA;AACA;;AAE+B;AAC/B;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAAuG;;AAEvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD,wDAAwD;AACxD,sBAAsB,4DAAU,CAAC,2DAAS,oCAAoC,IAAI,cAAc,iBAAiB;AACjH;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,yBAAyB,IAAI,oBAAoB,WAAW,cAAc,2BAA2B;AAC/I;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAU,CAAC,2DAAS;AACtC;AACA;AACA,uBAAuB,mDAAoB;;AAEQ;AACnD","file":"js/5-legacy.js","sourcesContent":["import { R as Request } from './lazy-chunk-request.es.js';\nimport { Coin, Network, getBip32Path, AddressTypeBitcoin, ErrorState, ErrorType } from './ledger-api.es.js';\n\nclass RequestBitcoin extends Request {\n    constructor(expectedWalletId) {\n        super(expectedWalletId);\n        this.coin = Coin.BITCOIN;\n        this.minRequiredAppVersion = '1.3.8'; // first version supporting web usb\n        // Preload dependencies. Bitcoin lib is preloaded individually by request child classes that need it.\n        // Ignore errors.\n        Promise.all([\n            this._loadLowLevelApi(),\n            this._isWalletIdDerivationRequired ? [import('./lazy-chunk-_commonjsHelpers.es.js'), import('./lazy-chunk-polyfill-node:buffer.es.js'), import('./lazy-chunk-sha256.es.js')][2].then(function (n) { return n.s; }) : null,\n        ]).catch(() => { });\n    }\n    get requiredApp() {\n        // Note that Ledger provides a separate Bitcoin testnet app which can be installed by enabling developer mode in\n        // Ledger Live. Operating on testnet paths is generally allowed also for the Bitcoin mainnet app and retrieved\n        // public keys (and thus also computed extended keys) and signed transactions are identical to the testnet app,\n        // however addresses displayed or generated by the Ledger are in mainnet format, regardless of whether a testnet\n        // path is specified. The testnet app since version 1.4.6 shows a warning when accessing mainnet paths. For\n        // these reason we generally block using the Bitcoin mainnet and testnet apps interchangeably.\n        return `Bitcoin${this.network === Network.TESTNET ? ' Test' : ''}`;\n    }\n    async checkCoinAppConnection(transport) {\n        const coinAppConnection = await super.checkCoinAppConnection(transport, 'BTC');\n        if (!this._isWalletIdDerivationRequired)\n            return coinAppConnection; // skip wallet id derivation\n        // Note that api and sha256 are preloaded in the constructor, therefore we don't need to optimize for load order\n        // or execution order here.\n        const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED on failure\n        // TODO For u2f and WebAuthn, the Ledger displays a confirmation screen to get the public key if the user has\n        //  this privacy setting enabled. The get public key functionality also supports setting a permission token\n        //  which however is not implemented in @ledgerhq/hw-app-btc and therefore would need to be implemented manually\n        const { publicKey } = await api.getWalletPublicKey(getBip32Path({\n            coin: Coin.BITCOIN,\n            addressType: AddressTypeBitcoin.LEGACY,\n            network: this.network,\n            accountIndex: 0,\n            addressIndex: 0,\n            isInternal: false,\n        }));\n        let Sha256;\n        try {\n            // Note that loading sha here only for wallet id calculation is not really wasteful as it's also imported\n            // by the ledger api and bitcoinjs.\n            Sha256 = (await [import('./lazy-chunk-_commonjsHelpers.es.js'), import('./lazy-chunk-polyfill-node:buffer.es.js'), import('./lazy-chunk-sha256.es.js')][2].then(function (n) { return n.s; })).default;\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);\n        }\n        const walletId = new Sha256().update(publicKey, 'hex').digest('base64');\n        this._checkExpectedWalletId(walletId);\n        coinAppConnection.walletId = walletId;\n        return coinAppConnection;\n    }\n    async _getLowLevelApi(transport) {\n        if (!RequestBitcoin._lowLevelApiPromise\n            || transport !== (await RequestBitcoin._lowLevelApiPromise).transport) {\n            // No low level api instantiated yet or transport / transport type changed in the meantime.\n            // Note that property transport exists on AppBtc but is not defined in the types. Unfortunately we can't\n            // use type augmentation as it's the default export and therefore we cast to any.\n            RequestBitcoin._lowLevelApiPromise = this._loadLowLevelApi()\n                .then((LowLevelApi) => new LowLevelApi(transport), (e) => {\n                RequestBitcoin._lowLevelApiPromise = null;\n                return Promise.reject(e);\n            });\n        }\n        return RequestBitcoin._lowLevelApiPromise;\n    }\n    async _loadLowLevelApi() {\n        try {\n            return (await [import('./lazy-chunk-polyfill-node:buffer.es.js'), import('./lazy-chunk-index.es.js'), import('./lazy-chunk-polyfill-node:process.es.js'), import('./lazy-chunk-index.es4.js'), import('./lazy-chunk-index.es3.js'), import('./lazy-chunk-events.es.js'), import('./lazy-chunk-_commonjsHelpers.es.js'), import('./lazy-chunk-sha256.es.js'), import('./lazy-chunk-Btc.es.js')][8]).default;\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);\n        }\n    }\n    async _loadBitcoinLib() {\n        try {\n            return await [import('./lazy-chunk-polyfill-node:buffer.es.js'), import('./lazy-chunk-sha256.es.js'), import('./lazy-chunk-index.es4.js'), import('./lazy-chunk-_commonjsHelpers.es.js'), import('./lazy-chunk-polyfill-node:process.es.js'), import('./lazy-chunk-events.es.js'), import('./lazy-chunk-bitcoin-lib.es.js')][6];\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.LOADING_DEPENDENCIES_FAILED, `Failed loading dependencies: ${e.message || e}`, this);\n        }\n    }\n}\nRequestBitcoin._lowLevelApiPromise = null;\n\nexport { RequestBitcoin as R };\n//# sourceMappingURL=lazy-chunk-request-bitcoin.es.js.map\n","import { O as Observable, ErrorState, ErrorType, R as REQUEST_EVENT_CANCEL } from './ledger-api.es.js';\n\n// Also see https://github.com/LedgerHQ/ledgerjs/issues/365 for other requests which might be interesting.\nasync function getAppNameAndVersion(transport, scrambleKey) {\n    // Taken from @ledgerhq/hw-app-btc/getAppAndVersion.js. We don't import it directly from there to avoid loading its\n    // unnecessary dependencies. Note that this request is common to all apps and the dashboard and is no Bitcoin app\n    // specific request (it's not on https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc but rather imple-\n    // mented in the Ledger Nano S and Nano X SDKs, see os_io_seproxyhal.c. Also mind the different cla). However, for\n    // u2f and WebAuthn the used scramble key must match the one of the connected app for the Ledger to answer the\n    // request. Therefore, decorate the api method manually to make it compatible with all apps, not only the Nimiq app.\n    const getAppNameAndVersionApi = {\n        async getAppNameAndVersion() {\n            // Note that no u2f heartbeat is required here as the call is not interactive but answers directly.\n            const response = await transport.send(0xb0, 0x01, 0x00, 0x00);\n            const status = response.slice(response.length - 2).readUInt16BE(0);\n            if (status !== 0x9000)\n                throw new Error('getAppNameAndVersion failed'); // should not actually happen\n            let offset = 0;\n            const format = response[offset++];\n            if (format !== 1)\n                throw new Error('Unsupported format');\n            const nameLength = response[offset++];\n            const name = response.slice(offset, (offset += nameLength)).toString('ascii');\n            const versionLength = response[offset++];\n            const version = response.slice(offset, (offset += versionLength)).toString('ascii');\n            return { name, version };\n        },\n    };\n    // Takes care of setting the api lock (for ledger busy errors) and scramble key. Note that decorating the api method\n    // does not modify the transport instance, therefore decorating on each invocation of getAppNameAndVersion does no\n    // harm. Also note that the lock is a property of the transport, thus works correctly across multiple independently\n    // decorated methods.\n    transport.decorateAppAPIMethods(getAppNameAndVersionApi, ['getAppNameAndVersion'], scrambleKey);\n    return getAppNameAndVersionApi.getAppNameAndVersion();\n}\n\nclass Request extends Observable {\n    constructor(expectedWalletId) {\n        super();\n        this._cancelled = false;\n        this.expectedWalletId = expectedWalletId;\n    }\n    static _isAppVersionSupported(versionString, minRequiredVersion) {\n        const version = versionString.split('.').map((part) => parseInt(part, 10));\n        const parsedMinRequiredVersion = minRequiredVersion.split('.').map((part) => parseInt(part, 10));\n        for (let i = 0; i < minRequiredVersion.length; ++i) {\n            if (typeof version[i] === 'undefined' || version[i] < parsedMinRequiredVersion[i])\n                return false;\n            if (version[i] > parsedMinRequiredVersion[i])\n                return true;\n        }\n        return true;\n    }\n    get cancelled() {\n        return this._cancelled;\n    }\n    canReuseCoinAppConnection(coinAppConnection) {\n        return coinAppConnection.coin === this.coin\n            && coinAppConnection.app === this.requiredApp\n            && Request._isAppVersionSupported(coinAppConnection.appVersion, this.minRequiredAppVersion)\n            && (!this.expectedWalletId || coinAppConnection.walletId === this.expectedWalletId);\n    }\n    cancel() {\n        if (this._cancelled)\n            return;\n        this._cancelled = true;\n        this.fire(Request.EVENT_CANCEL);\n    }\n    on(type, callback) {\n        if (type === Request.EVENT_CANCEL && this._cancelled) {\n            // trigger callback directly\n            callback();\n        }\n        super.on(type, callback);\n    }\n    async checkCoinAppConnection(transport, scrambleKey) {\n        const { name: app, version: appVersion } = await getAppNameAndVersion(transport, scrambleKey);\n        if (app !== this.requiredApp && app !== 'app') { // speculos reports 'app' as app name\n            throw new ErrorState(ErrorType.WRONG_APP, `Wrong app connected: ${app}, required: ${this.requiredApp}`, this);\n        }\n        if (!Request._isAppVersionSupported(appVersion, this.minRequiredAppVersion)) {\n            throw new ErrorState(ErrorType.APP_OUTDATED, `Ledger ${app} app is outdated: ${appVersion}, required: ${this.minRequiredAppVersion}`, this);\n        }\n        return { coin: this.coin, app, appVersion };\n    }\n    get _isWalletIdDerivationRequired() {\n        return !!this.expectedWalletId;\n    }\n    _checkExpectedWalletId(walletId) {\n        if (this.expectedWalletId === undefined || this.expectedWalletId === walletId)\n            return;\n        throw new ErrorState(ErrorType.WRONG_WALLET, 'Wrong wallet or Ledger connected', this);\n    }\n}\nRequest.EVENT_CANCEL = REQUEST_EVENT_CANCEL;\n\nexport { Request as R, getAppNameAndVersion as g };\n//# sourceMappingURL=lazy-chunk-request.es.js.map\n"],"sourceRoot":""}