{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-TransportWebAuthn.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAsE;AACmB;AACtD;;AAEnC;;AAEA;AACA;AACA,iBAAiB,wEAAM;;AAEvB,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,yDAAc;AAC5B;;AAEA;AACA,cAAc,yDAAc;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,aAAa,wEAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,gCAAgC,yDAAS;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,IAAI,iEAAG;AACP;AACA,IAAI,iEAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,uBAAuB,wEAAM;AAC7B;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB,yDAAc;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEe,gFAAiB,EAAC;AACjC","file":"js/27-legacy.js","sourcesContent":["import { B as Buffer } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { T as Transport, l as log, a as TransportError } from './lazy-chunk-index.es.js';\nimport './lazy-chunk-events.es.js';\n\nvar wrapApdu_1 = wrapApdu;\n\nfunction wrapApdu(apdu, key) {\n  if (apdu.length === 0) return apdu;\n  const result = Buffer.alloc(apdu.length);\n\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n\n  return result;\n}\n\nconst attemptExchange = (apdu, timeout, scrambleKey) => {\n  if (!scrambleKey) {\n    throw new TransportError(\"transport.setScrambleKey must be used to set a scramble key. Refer to documentation.\", \"NoScrambleKey\");\n  }\n\n  if (!navigator.credentials) {\n    throw new TransportError(\"WebAuthn not supported\", \"NotSupported\");\n  }\n\n  return navigator.credentials // $FlowFixMe\n  .get({\n    publicKey: {\n      timeout,\n      challenge: new Uint8Array(32),\n      allowCredentials: [{\n        type: \"public-key\",\n        id: new Uint8Array(wrapApdu_1(apdu, scrambleKey))\n      }]\n    }\n  }) // $FlowFixMe\n  .then(r => Buffer.from(r.response.signature));\n};\n/**\n * WebAuthn Transport implementation\n * @example\n * import TransportWebAuthn from \"@ledgerhq/hw-transport-webauthn\";\n * ...\n * TransportWebAuthn.create().then(transport => ...)\n */\n\n\nclass TransportWebAuthn extends Transport {\n  constructor(...args) {\n    super(...args);\n    this.scrambleKey = void 0;\n  }\n\n  static async open() {\n    return new TransportWebAuthn();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  async exchange(apdu) {\n    log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n    const res = await attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey);\n    log(\"apdu\", \"<= \" + res.toString(\"hex\"));\n    return res;\n  }\n  /**\n   * A scramble key is a string that xor the data exchanged.\n   * It depends on the device app you need to exchange with.\n   * For instance it can be \"BTC\" for the bitcoin app, \"B0L0S\" for the dashboard.\n   *\n   * @example\n   * transport.setScrambleKey(\"B0L0S\")\n   */\n\n\n  setScrambleKey(scrambleKey) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  close() {\n    return Promise.resolve();\n  }\n\n}\n\nTransportWebAuthn.isSupported = () => Promise.resolve(!!navigator.credentials);\n\nTransportWebAuthn.list = () => navigator.credentials ? [null] : [];\n\nTransportWebAuthn.listen = observer => {\n  setTimeout(() => {\n    if (!navigator.credentials) {\n      observer.error(new TransportError(\"WebAuthn not supported\", \"NotSupported\"));\n      return {\n        unsubscribe: () => {}\n      };\n    }\n\n    observer.next({\n      type: \"add\",\n      descriptor: null\n    });\n    observer.complete();\n  }, 0);\n  return {\n    unsubscribe: () => {}\n  };\n};\n\nexport default TransportWebAuthn;\n//# sourceMappingURL=lazy-chunk-TransportWebAuthn.es.js.map\n"],"sourceRoot":""}