{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-Btc.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AAClB;AACsB;AACF;AAChB;AACrB;AACU;AACV;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,wEAAM;AACxB;;AAEA;AACA;AACA;AACA,mBAAmB,wEAAM;;AAEzB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D,wEAAM;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wEAAM;AACrB;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,wEAAM;AACzB;AACA;AACA;;AAEA;AACA,mBAAmB,wEAAM;AACzB;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,wEAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB,EAAE;AACxB,uBAAuB,wBAAwB;AAC/C,sBAAsB,uBAAuB;AAC7C,wBAAwB,yBAAyB;AACjD,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,uBAAuB,EAAE;AACzB,sBAAsB,uBAAuB;AAC7C,sBAAsB,uBAAuB;AAC7C,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAM;AACxB,sBAAsB,wEAAM;AAC5B,wBAAwB,wEAAM;AAC9B,kBAAkB,wEAAM;AACxB;AACA,sBAAsB,wEAAM;AAC5B;AACA,oCAAoC,wEAAM,mDAAmD,wEAAM;AACnG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA,iBAAiB,wEAAM;AACvB,eAAe,wEAAM,UAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AA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M,yBAAyB,wEAAM,sBAAsB,wEAAM,+BAA+B,wEAAM;;AAEnO;AACA,aAAa,wEAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,SAAS,0DAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,4KAA4K;AAC5K;;AAEA,qBAAqB,wEAAM;AAC3B,sBAAsB,wEAAM;AAC5B,yBAAyB,wEAAM;AAC/B,qLAAqL;;AAErL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAM;AACrB;AACA;AACA,uBAAuB,wEAAM;AAC7B,eAAe;;AAEf;AACA;AACA;AACA,MAAM,iEAAG;AACT,qBAAqB,wEAAM;AAC3B;AACA;AACA;AACA,eAAe,wEAAM;AACrB;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,wEAAM;AAChD,qDAAqD;AACrD;;AAEA,oCAAoC,wEAAM;AAC1C,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,wEAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC,wCAAwC,wEAAM;AAC9C;AACA;;AAEA;AACA,kCAAkC,wEAAM;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH,iBAAiB,mBAAmB;AACpC;AACA,yEAAyE,wEAAM,8DAA8D,wEAAM,SAAS,wEAAM,sEAAsE,wEAAM;AAC9O,mCAAmC;AACnC;;AAEA;AACA,0BAA0B;AAC1B;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH,iBAAiB,mBAAmB;AACpC;AACA,kCAAkC,wEAAM;;AAExC;AACA,6CAA6C,wEAAM,SAAS,wEAAM;AAClE;AACA,KAAK;AACL,4BAA4B,wEAAM;AAClC,sBAAsB,wEAAM;AAC5B;AACA;AACA,2CAA2C,wEAAM;AACjD;;AAEA;AACA;AACA;;AAEA,yBAAyB,wEAAM;AAC/B;AACA,eAAe,wEAAM;;AAErB;AACA,kBAAkB,wEAAM;;AAExB,mBAAmB,mBAAmB;AACtC,0BAA0B,wEAAM,SAAS,wEAAM,oBAAoB,wEAAM,8CAA8C,wEAAM;AAC7H,gBAAgB,wEAAM;AACtB;;AAEA,aAAa,wEAAM;AACnB,GAAG;AACH;AACA;AACA;;;AAGA,WAAW,wEAAM;;AAEjB;AACA,aAAa,wEAAM,oDAAoD,wEAAM,0CAA0C,wEAAM;AAC7H;;AAEA;AACA,wBAAwB,wEAAM;AAC9B;AACA,sBAAsB,wEAAM,wBAAwB,wEAAM,yDAAyD,wEAAM;AACzH,MAAM,wEAAM;AACZ,MAAM,wEAAM;AACZ,KAAK;AACL,aAAa,wEAAM;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA,IAAI;AACJ;;AAEA,qBAAqB,wEAAM;AAC3B,sBAAsB,wEAAM;AAC5B,yBAAyB,wEAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAM;;AAE7B;AACA;AACA;AACA,qBAAqB,wEAAM;AAC3B;AACA;AACA;AACA,wBAAwB,wEAAM,6BAA6B,wEAAM;AACjE;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH,iBAAiB,mBAAmB;AACpC,mBAAmB,wEAAM;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA,yEAAyE,wEAAM;AAC/E,mCAAmC;AACnC;;AAEA;AACA,0BAA0B;AAC1B;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;;;AAGA;AACA;;AAEA;AACA,iHAAiH,iBAAiB;AAClI;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+CAA+C;AAC/C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sBAAsB,iBAAiB;AAC3C;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEe,kEAAG,EAAC;AACnB","file":"js/26.js","sourcesContent":["import { B as Buffer } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { l as log } from './lazy-chunk-index.es.js';\nimport { b as browser$1 } from './lazy-chunk-polyfill-node:process.es.js';\nimport { s as sha_js, r as ripemd160 } from './lazy-chunk-index.es4.js';\nimport { s as semver } from './lazy-chunk-index.es3.js';\nimport './lazy-chunk-events.es.js';\nimport './lazy-chunk-_commonjsHelpers.es.js';\nimport './lazy-chunk-sha256.es.js';\n\n/*\n * Bitcoin BIP32 path helpers\n * (C) 2016 Alex Beregszaszi\n */\nconst HARDENED = 0x80000000;\n\nvar BIPPath = function (path) {\n  if (!Array.isArray(path)) {\n    throw new Error('Input must be an Array')\n  }\n  if (path.length === 0) {\n    throw new Error('Path must contain at least one level')\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (typeof path[i] !== 'number') {\n      throw new Error('Path element is not a number')\n    }\n  }\n  this.path = path;\n};\n\nBIPPath.validatePathArray = function (path) {\n  try {\n    BIPPath.fromPathArray(path);\n    return true\n  } catch (e) {\n    return false\n  }\n};\n\nBIPPath.validateString = function (text, reqRoot) {\n  try {\n    BIPPath.fromString(text, reqRoot);\n    return true\n  } catch (e) {\n    return false\n  }\n};\n\nBIPPath.fromPathArray = function (path) {\n  return new BIPPath(path)\n};\n\nBIPPath.fromString = function (text, reqRoot) {\n  // skip the root\n  if (/^m\\//i.test(text)) {\n    text = text.slice(2);\n  } else if (reqRoot) {\n    throw new Error('Root element is required')\n  }\n\n  var path = text.split('/');\n  var ret = new Array(path.length);\n  for (var i = 0; i < path.length; i++) {\n    var tmp = /(\\d+)([hH\\']?)/.exec(path[i]);\n    if (tmp === null) {\n      throw new Error('Invalid input')\n    }\n    ret[i] = parseInt(tmp[1], 10);\n\n    if (ret[i] >= HARDENED) {\n      throw new Error('Invalid child index')\n    }\n\n    if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\\'') {\n      ret[i] += HARDENED;\n    } else if (tmp[2].length != 0) {\n      throw new Error('Invalid modifier')\n    }\n  }\n  return new BIPPath(ret)\n};\n\nBIPPath.prototype.toPathArray = function () {\n  return this.path\n};\n\nBIPPath.prototype.toString = function (noRoot, oldStyle) {\n  var ret = new Array(this.path.length);\n  for (var i = 0; i < this.path.length; i++) {\n    var tmp = this.path[i];\n    if (tmp & HARDENED) {\n      ret[i] = (tmp & ~HARDENED) + (oldStyle ? 'h' : '\\'');\n    } else {\n      ret[i] = tmp;\n    }\n  }\n  return (noRoot ? '' : 'm/') + ret.join('/')\n};\n\nBIPPath.prototype.inspect = function () {\n  return 'BIPPath <' + this.toString() + '>'\n};\n\nvar bip32Path = BIPPath;\n\n// flow\nconst MAX_SCRIPT_BLOCK = 50;\nconst DEFAULT_VERSION = 1;\nconst DEFAULT_LOCKTIME = 0;\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst SIGHASH_ALL = 1;\nconst OP_DUP = 0x76;\nconst OP_HASH160 = 0xa9;\nconst HASH_SIZE = 0x14;\nconst OP_EQUALVERIFY = 0x88;\nconst OP_CHECKSIG = 0xac;\n\nasync function signMessage(transport, {\n  path,\n  messageHex\n}) {\n  const paths = bip32Path.fromString(path).toPathArray();\n  const message = Buffer.from(messageHex, \"hex\");\n  let offset = 0;\n\n  while (offset !== message.length) {\n    let maxChunkSize = offset === 0 ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4 : MAX_SCRIPT_BLOCK;\n    let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n    const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);\n\n    if (offset === 0) {\n      buffer[0] = paths.length;\n      paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n      message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);\n    } else {\n      message.copy(buffer, 0, offset, offset + chunkSize);\n    }\n\n    await transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n    offset += chunkSize;\n  }\n\n  const res = await transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n  const v = res[0] - 0x30;\n  let r = res.slice(4, 4 + res[3]);\n\n  if (r[0] === 0) {\n    r = r.slice(1);\n  }\n\n  r = r.toString(\"hex\");\n  offset = 4 + res[3] + 2;\n  let s = res.slice(offset, offset + res[offset - 1]);\n\n  if (s[0] === 0) {\n    s = s.slice(1);\n  }\n\n  s = s.toString(\"hex\");\n  return {\n    v,\n    r,\n    s\n  };\n}\n\nfunction bip32asBuffer(path) {\n  const paths = !path ? [] : bip32Path.fromString(path).toPathArray();\n  let buffer = Buffer.alloc(1 + paths.length * 4);\n  buffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  return buffer;\n}\n\n/**\n * address format is one of legacy | p2sh | bech32 | cashaddr\n */\n\nconst addressFormatMap = {\n  legacy: 0,\n  p2sh: 1,\n  bech32: 2,\n  cashaddr: 3\n};\nasync function getWalletPublicKey(transport, options) {\n  const {\n    path,\n    verify,\n    format\n  } = {\n    verify: false,\n    format: \"legacy\",\n    ...options\n  };\n\n  if (!(format in addressFormatMap)) {\n    throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n  }\n\n  const buffer = bip32asBuffer(path);\n  var p1 = verify ? 1 : 0;\n  var p2 = addressFormatMap[format];\n  const response = await transport.send(0xe0, 0x40, p1, p2, buffer);\n  const publicKeyLength = response[0];\n  const addressLength = response[1 + publicKeyLength];\n  const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n  const bitcoinAddress = response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n  const chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n  return {\n    publicKey,\n    bitcoinAddress,\n    chainCode\n  };\n}\n//# sourceMappingURL=getWalletPublicKey.js.map\n\nfunction getVarint(data, offset) {\n  if (data[offset] < 0xfd) {\n    return [data[offset], 1];\n  }\n\n  if (data[offset] === 0xfd) {\n    return [(data[offset + 2] << 8) + data[offset + 1], 3];\n  }\n\n  if (data[offset] === 0xfe) {\n    return [(data[offset + 4] << 24) + (data[offset + 3] << 16) + (data[offset + 2] << 8) + data[offset + 1], 5];\n  }\n\n  throw new Error(\"getVarint called with unexpected parameters\");\n}\nfunction createVarint(value) {\n  if (value < 0xfd) {\n    const buffer = Buffer.alloc(1);\n    buffer[0] = value;\n    return buffer;\n  }\n\n  if (value <= 0xffff) {\n    const buffer = Buffer.alloc(3);\n    buffer[0] = 0xfd;\n    buffer[1] = value & 0xff;\n    buffer[2] = value >> 8 & 0xff;\n    return buffer;\n  }\n\n  const buffer = Buffer.alloc(5);\n  buffer[0] = 0xfe;\n  buffer[1] = value & 0xff;\n  buffer[2] = value >> 8 & 0xff;\n  buffer[3] = value >> 16 & 0xff;\n  buffer[4] = value >> 24 & 0xff;\n  return buffer;\n}\n\nfunction formatTransactionDebug(transaction) {\n  let str = \"TX\";\n  str += \" version \" + transaction.version.toString(\"hex\");\n\n  if (transaction.locktime) {\n    str += \" locktime \" + transaction.locktime.toString(\"hex\");\n  }\n\n  if (transaction.witness) {\n    str += \" witness \" + transaction.witness.toString(\"hex\");\n  }\n\n  if (transaction.timestamp) {\n    str += \" timestamp \" + transaction.timestamp.toString(\"hex\");\n  }\n\n  if (transaction.nVersionGroupId) {\n    str += \" nVersionGroupId \" + transaction.nVersionGroupId.toString(\"hex\");\n  }\n\n  if (transaction.nExpiryHeight) {\n    str += \" nExpiryHeight \" + transaction.nExpiryHeight.toString(\"hex\");\n  }\n\n  if (transaction.extraData) {\n    str += \" extraData \" + transaction.extraData.toString(\"hex\");\n  }\n\n  transaction.inputs.forEach(({\n    prevout,\n    script,\n    sequence\n  }, i) => {\n    str += `\\ninput ${i}:`;\n    str += ` prevout ${prevout.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n    str += ` sequence ${sequence.toString(\"hex\")}`;\n  });\n  (transaction.outputs || []).forEach(({\n    amount,\n    script\n  }, i) => {\n    str += `\\noutput ${i}:`;\n    str += ` amount ${amount.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n  });\n  return str;\n}\n\nfunction splitTransaction(transactionHex, isSegwitSupported = false, hasTimestamp = false, hasExtraData = false, additionals = []) {\n  const inputs = [];\n  const outputs = [];\n  var witness = false;\n  let offset = 0;\n  let timestamp = Buffer.alloc(0);\n  let nExpiryHeight = Buffer.alloc(0);\n  let nVersionGroupId = Buffer.alloc(0);\n  let extraData = Buffer.alloc(0);\n  const isDecred = additionals.includes(\"decred\");\n  const transaction = Buffer.from(transactionHex, \"hex\");\n  const version = transaction.slice(offset, offset + 4);\n  const overwinter = version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) || version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80]));\n  offset += 4;\n\n  if (!hasTimestamp && isSegwitSupported && transaction[offset] === 0 && transaction[offset + 1] !== 0) {\n    offset += 2;\n    witness = true;\n  }\n\n  if (hasTimestamp) {\n    timestamp = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n\n  if (overwinter) {\n    nVersionGroupId = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n\n  let varint = getVarint(transaction, offset);\n  const numberInputs = varint[0];\n  offset += varint[1];\n\n  for (let i = 0; i < numberInputs; i++) {\n    const prevout = transaction.slice(offset, offset + 36);\n    offset += 36;\n    let script = Buffer.alloc(0);\n    let tree = Buffer.alloc(0); //No script for decred, it has a witness\n\n    if (!isDecred) {\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n    } else {\n      //Tree field\n      tree = transaction.slice(offset, offset + 1);\n      offset += 1;\n    }\n\n    const sequence = transaction.slice(offset, offset + 4);\n    offset += 4;\n    inputs.push({\n      prevout,\n      script,\n      sequence,\n      tree\n    });\n  }\n\n  varint = getVarint(transaction, offset);\n  const numberOutputs = varint[0];\n  offset += varint[1];\n\n  for (let i = 0; i < numberOutputs; i++) {\n    const amount = transaction.slice(offset, offset + 8);\n    offset += 8;\n\n    if (isDecred) {\n      //Script version\n      offset += 2;\n    }\n\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n    const script = transaction.slice(offset, offset + varint[0]);\n    offset += varint[0];\n    outputs.push({\n      amount,\n      script\n    });\n  }\n\n  let witnessScript, locktime;\n\n  if (witness) {\n    witnessScript = transaction.slice(offset, -4);\n    locktime = transaction.slice(transaction.length - 4);\n  } else {\n    locktime = transaction.slice(offset, offset + 4);\n  }\n\n  offset += 4;\n\n  if (overwinter || isDecred) {\n    nExpiryHeight = transaction.slice(offset, offset + 4);\n    offset += 4;\n  }\n\n  if (hasExtraData) {\n    extraData = transaction.slice(offset);\n  } //Get witnesses for Decred\n\n\n  if (isDecred) {\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n\n    if (varint[0] !== numberInputs) {\n      throw new Error(\"splitTransaction: incoherent number of witnesses\");\n    }\n\n    for (let i = 0; i < numberInputs; i++) {\n      //amount\n      offset += 8; //block height\n\n      offset += 4; //block index\n\n      offset += 4; //Script size\n\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      inputs[i].script = script;\n    }\n  }\n\n  const t = {\n    version,\n    inputs,\n    outputs,\n    locktime,\n    witness: witnessScript,\n    timestamp,\n    nVersionGroupId,\n    nExpiryHeight,\n    extraData\n  };\n  log(\"btc\", `splitTransaction ${transactionHex}:\\n${formatTransactionDebug(t)}`);\n  return t;\n}\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (browser$1.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nvar browser = invariant;\n\nasync function getTrustedInputRaw(transport, transactionData, indexLookup) {\n  let data;\n  let firstRound = false;\n\n  if (typeof indexLookup === \"number\") {\n    firstRound = true;\n    const prefix = Buffer.alloc(4);\n    prefix.writeUInt32BE(indexLookup, 0);\n    data = Buffer.concat([prefix, transactionData], transactionData.length + 4);\n  } else {\n    data = transactionData;\n  }\n\n  const trustedInput = await transport.send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data);\n  const res = trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\");\n  return res;\n}\nasync function getTrustedInput(transport, indexLookup, transaction, additionals = []) {\n  const {\n    version,\n    inputs,\n    outputs,\n    locktime,\n    nExpiryHeight,\n    extraData\n  } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n  const isXST = additionals.includes(\"stealthcoin\");\n\n  const processScriptBlocks = async (script, sequence) => {\n    const seq = sequence || Buffer.alloc(0);\n    const scriptBlocks = [];\n    let offset = 0;\n\n    while (offset !== script.length) {\n      let blockSize = script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : script.length - offset;\n\n      if (offset + blockSize !== script.length) {\n        scriptBlocks.push(script.slice(offset, offset + blockSize));\n      } else {\n        scriptBlocks.push(Buffer.concat([script.slice(offset, offset + blockSize), seq]));\n      }\n\n      offset += blockSize;\n    } // Handle case when no script length: we still want to pass the sequence\n    // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n\n\n    if (script.length === 0) {\n      scriptBlocks.push(seq);\n    }\n\n    let res;\n\n    for (let scriptBlock of scriptBlocks) {\n      res = await getTrustedInputRaw(transport, scriptBlock);\n    }\n\n    return res;\n  };\n\n  const processWholeScriptBlock = block => getTrustedInputRaw(transport, block);\n\n  await getTrustedInputRaw(transport, Buffer.concat([transaction.version, transaction.timestamp || Buffer.alloc(0), transaction.nVersionGroupId || Buffer.alloc(0), createVarint(inputs.length)]), indexLookup);\n\n  for (let input of inputs) {\n    const isXSTV2 = isXST && Buffer.compare(version, Buffer.from([0x02, 0x00, 0x00, 0x00])) === 0;\n    const treeField = isDecred ? input.tree || Buffer.from([0x00]) : Buffer.alloc(0);\n    const data = Buffer.concat([input.prevout, treeField, isXSTV2 ? Buffer.from([0x00]) : createVarint(input.script.length)]);\n    await getTrustedInputRaw(transport, data); // iteration (eachSeries) ended\n    // TODO notify progress\n    // deferred.notify(\"input\");\n    // Reference: https://github.com/StealthSend/Stealth/commit/5be35d6c2c500b32ed82e5d6913d66d18a4b0a7f#diff-e8db9b851adc2422aadfffca88f14c91R566\n\n    await (isDecred ? processWholeScriptBlock(Buffer.concat([input.script, input.sequence])) : isXSTV2 ? processWholeScriptBlock(input.sequence) : processScriptBlocks(input.script, input.sequence));\n  }\n\n  await getTrustedInputRaw(transport, createVarint(outputs.length));\n\n  for (let output of outputs) {\n    const data = Buffer.concat([output.amount, isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n    createVarint(output.script.length), output.script]);\n    await getTrustedInputRaw(transport, data);\n  }\n\n  const endData = [];\n\n  if (nExpiryHeight && nExpiryHeight.length > 0) {\n    endData.push(nExpiryHeight);\n  }\n\n  if (extraData && extraData.length > 0) {\n    endData.push(extraData);\n  }\n\n  let extraPart;\n\n  if (endData.length) {\n    const data = Buffer.concat(endData);\n    extraPart = isDecred ? data : Buffer.concat([createVarint(data.length), data]);\n  }\n\n  const res = await processScriptBlocks(Buffer.concat([locktime, extraPart || Buffer.alloc(0)]));\n  browser(res, \"missing result in processScriptBlocks\");\n  return res;\n}\n\n/**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n\nfunction serializeTransactionOutputs({\n  outputs\n}) {\n  let outputBuffer = Buffer.alloc(0);\n\n  if (typeof outputs !== \"undefined\") {\n    outputBuffer = Buffer.concat([outputBuffer, createVarint(outputs.length)]);\n    outputs.forEach(output => {\n      outputBuffer = Buffer.concat([outputBuffer, output.amount, createVarint(output.script.length), output.script]);\n    });\n  }\n\n  return outputBuffer;\n}\nfunction serializeTransaction(transaction, skipWitness, timestamp, additionals = []) {\n  const isDecred = additionals.includes(\"decred\");\n  const isBech32 = additionals.includes(\"bech32\");\n  let inputBuffer = Buffer.alloc(0);\n  let useWitness = typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n  transaction.inputs.forEach(input => {\n    inputBuffer = isDecred || isBech32 ? Buffer.concat([inputBuffer, input.prevout, Buffer.from([0x00]), //tree\n    input.sequence]) : Buffer.concat([inputBuffer, input.prevout, createVarint(input.script.length), input.script, input.sequence]);\n  });\n  let outputBuffer = serializeTransactionOutputs(transaction);\n\n  if (typeof transaction.outputs !== \"undefined\" && typeof transaction.locktime !== \"undefined\") {\n    outputBuffer = Buffer.concat([outputBuffer, useWitness && transaction.witness || Buffer.alloc(0), transaction.locktime, transaction.nExpiryHeight || Buffer.alloc(0), transaction.extraData || Buffer.alloc(0)]);\n  }\n\n  return Buffer.concat([transaction.version, timestamp ? timestamp : Buffer.alloc(0), transaction.nVersionGroupId || Buffer.alloc(0), useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0), createVarint(transaction.inputs.length), inputBuffer, outputBuffer]);\n}\n\nfunction getTrustedInputBIP143(transport, indexLookup, transaction, additionals = []) {\n  if (!transaction) {\n    throw new Error(\"getTrustedInputBIP143: missing tx\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n\n  if (isDecred) {\n    throw new Error(\"Decred does not implement BIP143\");\n  }\n\n  let hash = sha_js(\"sha256\").update(sha_js(\"sha256\").update(serializeTransaction(transaction, true)).digest()).digest();\n  const data = Buffer.alloc(4);\n  data.writeUInt32LE(indexLookup, 0);\n  const {\n    outputs,\n    locktime\n  } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n  }\n\n  if (!outputs[indexLookup]) {\n    throw new Error(\"getTrustedInputBIP143: wrong index\");\n  }\n\n  hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n  return hash.toString(\"hex\");\n}\n\nfunction hashPublicKey(buffer) {\n  return new ripemd160().update(sha_js(\"sha256\").update(buffer).digest()).digest();\n}\n\nfunction startUntrustedHashTransactionInputRaw(transport, newTransaction, firstRound, transactionData, bip143 = false, overwinter = false, additionals = []) {\n  const p2 = additionals.includes(\"cashaddr\") ? 0x03 : bip143 ? additionals.includes(\"sapling\") ? 0x05 : overwinter ? 0x04 : 0x02 : 0x00;\n  return transport.send(0xe0, 0x44, firstRound ? 0x00 : 0x80, newTransaction ? p2 : 0x80, transactionData);\n}\nasync function startUntrustedHashTransactionInput(transport, newTransaction, transaction, inputs, bip143 = false, overwinter = false, additionals = [], useTrustedInputForSegwit = false) {\n  let data = Buffer.concat([transaction.version, transaction.timestamp || Buffer.alloc(0), transaction.nVersionGroupId || Buffer.alloc(0), createVarint(transaction.inputs.length)]);\n  await startUntrustedHashTransactionInputRaw(transport, newTransaction, true, data, bip143, overwinter, additionals);\n  let i = 0;\n  const isDecred = additionals.includes(\"decred\");\n\n  for (let input of transaction.inputs) {\n    let prefix;\n    let inputValue = inputs[i].value;\n\n    if (bip143) {\n      if (useTrustedInputForSegwit && inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputValue.length]);\n      } else {\n        prefix = Buffer.from([0x02]);\n      }\n    } else {\n      if (inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputs[i].value.length]);\n      } else {\n        prefix = Buffer.from([0x00]);\n      }\n    }\n\n    data = Buffer.concat([prefix, inputValue, isDecred ? Buffer.from([0x00]) : Buffer.alloc(0), createVarint(input.script.length)]);\n    await startUntrustedHashTransactionInputRaw(transport, newTransaction, false, data, bip143, overwinter, additionals);\n    let scriptBlocks = [];\n    let offset = 0;\n\n    if (input.script.length === 0) {\n      scriptBlocks.push(input.sequence);\n    } else {\n      while (offset !== input.script.length) {\n        let blockSize = input.script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : input.script.length - offset;\n\n        if (offset + blockSize !== input.script.length) {\n          scriptBlocks.push(input.script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(Buffer.concat([input.script.slice(offset, offset + blockSize), input.sequence]));\n        }\n\n        offset += blockSize;\n      }\n    }\n\n    for (let scriptBlock of scriptBlocks) {\n      await startUntrustedHashTransactionInputRaw(transport, newTransaction, false, scriptBlock, bip143, overwinter, additionals);\n    }\n\n    i++;\n  }\n}\n\nfunction compressPublicKey(publicKey) {\n  const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n  const prefixBuffer = Buffer.alloc(1);\n  prefixBuffer[0] = prefix;\n  return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n}\n\nfunction signTransaction(transport, path, lockTime, sigHashType, expiryHeight, additionals = []) {\n  const isDecred = additionals.includes(\"decred\");\n  const pathsBuffer = bip32asBuffer(path);\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32BE(lockTime, 0);\n  let buffer = isDecred ? Buffer.concat([pathsBuffer, lockTimeBuffer, expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]), Buffer.from([sigHashType])]) : Buffer.concat([pathsBuffer, Buffer.from([0x00]), lockTimeBuffer, Buffer.from([sigHashType])]);\n\n  if (expiryHeight && !isDecred) {\n    buffer = Buffer.concat([buffer, expiryHeight]);\n  }\n\n  return transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n    if (result.length > 0) {\n      result[0] = 0x30;\n      return result.slice(0, result.length - 2);\n    }\n\n    return result;\n  });\n}\n\nfunction provideOutputFullChangePath(transport, path) {\n  let buffer = bip32asBuffer(path);\n  return transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n}\nasync function hashOutputFull(transport, outputScript, additionals = []) {\n  let offset = 0;\n  let p1 = 0x80;\n  const isDecred = additionals.includes(\"decred\"); ///WARNING: Decred works only with one call (without chunking)\n  //TODO: test without this for Decred\n\n  if (isDecred) {\n    return transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n  }\n\n  while (offset < outputScript.length) {\n    let blockSize = offset + MAX_SCRIPT_BLOCK >= outputScript.length ? outputScript.length - offset : MAX_SCRIPT_BLOCK;\n    let p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n    let data = outputScript.slice(offset, offset + blockSize);\n    await transport.send(0xe0, 0x4a, p1, 0x00, data);\n    offset += blockSize;\n  }\n}\n//# sourceMappingURL=finalizeInput.js.map\n\nconst getAppAndVersion = async (transport) => {\n  const r = await transport.send(0xb0, 0x01, 0x00, 0x00);\n  let i = 0;\n  const format = r[i++];\n  browser(format === 1, \"getAppAndVersion: format not supported\");\n  const nameLength = r[i++];\n  const name = r.slice(i, i += nameLength).toString(\"ascii\");\n  const versionLength = r[i++];\n  const version = r.slice(i, i += versionLength).toString(\"ascii\");\n  const flagLength = r[i++];\n  const flags = r.slice(i, i += flagLength);\n  return {\n    name,\n    version,\n    flags\n  };\n};\n\nfunction shouldUseTrustedInputForSegwit({\n  version,\n  name\n}) {\n  if (name === \"Decred\") return false;\n  if (name === \"Exchange\") return true;\n  return semver.gte(version, \"1.4.0\");\n}\n\nconst defaultsSignTransaction = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  additionals: [],\n  onDeviceStreaming: _e => {},\n  onDeviceSignatureGranted: () => {},\n  onDeviceSignatureRequested: () => {}\n};\n/**\n *\n */\n\nasync function createTransaction(transport, arg) {\n  let {\n    inputs,\n    associatedKeysets,\n    changePath,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    initialTimestamp,\n    additionals,\n    expiryHeight,\n    useTrustedInputForSegwit,\n    onDeviceStreaming,\n    onDeviceSignatureGranted,\n    onDeviceSignatureRequested\n  } = { ...defaultsSignTransaction,\n    ...arg\n  };\n\n  if (useTrustedInputForSegwit === undefined) {\n    try {\n      const a = await getAppAndVersion(transport);\n      useTrustedInputForSegwit = shouldUseTrustedInputForSegwit(a);\n    } catch (e) {\n      if (e.statusCode === 0x6d00) {\n        useTrustedInputForSegwit = false;\n      } else {\n        throw e;\n      }\n    }\n  } // loop: 0 or 1 (before and after)\n  // i: index of the input being streamed\n  // i goes on 0...n, inluding n. in order for the progress value to go to 1\n  // we normalize the 2 loops to make a global percentage\n\n\n  const notify = (loop, i) => {\n    const {\n      length\n    } = inputs;\n    if (length < 3) return; // there is not enough significant event to worth notifying (aka just use a spinner)\n\n    const index = length * loop + i;\n    const total = 2 * length;\n    const progress = index / total;\n    onDeviceStreaming({\n      progress,\n      total,\n      index\n    });\n  };\n\n  const isDecred = additionals.includes(\"decred\");\n  const isXST = additionals.includes(\"stealthcoin\");\n  let startTime = Date.now();\n  const sapling = additionals.includes(\"sapling\");\n  const bech32 = segwit && additionals.includes(\"bech32\");\n  let useBip143 = segwit || !!additionals && (additionals.includes(\"abc\") || additionals.includes(\"gold\") || additionals.includes(\"bip143\")) || !!expiryHeight && !isDecred; // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  !!expiryHeight && !isDecred ? defaultVersion.writeUInt32LE(sapling ? 0x80000004 : 0x80000003, 0) : isXST ? defaultVersion.writeUInt32LE(2, 0) : defaultVersion.writeUInt32LE(1, 0); // Default version to 2 for XST not to have timestamp\n\n  const trustedInputs = [];\n  const regularOutputs = [];\n  const signatures = [];\n  const publicKeys = [];\n  let firstRun = true;\n  const targetTransaction = {\n    inputs: [],\n    version: defaultVersion,\n    timestamp: Buffer.alloc(0)\n  };\n  const getTrustedInputCall = useBip143 && !useTrustedInputForSegwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n  notify(0, 0); // first pass on inputs to get trusted inputs\n\n  for (let input of inputs) {\n    {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0], additionals);\n      log(\"hw\", \"got trustedInput=\" + trustedInput);\n      let sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE, 0);\n      trustedInputs.push({\n        trustedInput: true,\n        value: Buffer.from(trustedInput, \"hex\"),\n        sequence\n      });\n    }\n\n    const {\n      outputs\n    } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n\n    if (expiryHeight && !isDecred) {\n      targetTransaction.nVersionGroupId = Buffer.from(sapling ? [0x85, 0x20, 0x2f, 0x89] : [0x70, 0x82, 0xc4, 0x03]);\n      targetTransaction.nExpiryHeight = expiryHeight; // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n      // Overwinter : use nJoinSplit (1)\n\n      targetTransaction.extraData = Buffer.from(sapling ? [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] : [0x00]);\n    } else if (isDecred) {\n      targetTransaction.nExpiryHeight = expiryHeight;\n    }\n  }\n\n  targetTransaction.inputs = inputs.map(input => {\n    let sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE, 0);\n    return {\n      script: nullScript,\n      prevout: nullPrevout,\n      sequence\n    };\n  });\n\n  {\n    // Collect public keys\n    const result = [];\n\n    for (let i = 0; i < inputs.length; i++) {\n      const r = await getWalletPublicKey(transport, {\n        path: associatedKeysets[i]\n      });\n      notify(0, i + 1);\n      result.push(r);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      publicKeys.push(compressPublicKey(Buffer.from(result[i].publicKey, \"hex\")));\n    }\n  }\n\n  if (initialTimestamp !== undefined) {\n    targetTransaction.timestamp = Buffer.alloc(4);\n    targetTransaction.timestamp.writeUInt32LE(Math.floor(initialTimestamp + (Date.now() - startTime) / 1000), 0);\n  }\n\n  onDeviceSignatureRequested();\n\n  if (useBip143) {\n    // Do the first run with all inputs\n    await startUntrustedHashTransactionInput(transport, true, targetTransaction, trustedInputs, true, !!expiryHeight, additionals, useTrustedInputForSegwit);\n\n    if (changePath) {\n      await provideOutputFullChangePath(transport, changePath);\n    }\n\n    await hashOutputFull(transport, outputScript);\n  }\n\n  if (!!expiryHeight && !isDecred) {\n    await signTransaction(transport, \"\", lockTime, SIGHASH_ALL, expiryHeight);\n  } // Do the second run with the individual transaction\n\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    let script = inputs[i].length >= 3 && typeof input[2] === \"string\" ? Buffer.from(input[2], \"hex\") : !segwit ? regularOutputs[i].script : Buffer.concat([Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]), hashPublicKey(publicKeys[i]), Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG])]);\n    let pseudoTX = Object.assign({}, targetTransaction);\n    let pseudoTrustedInputs = useBip143 ? [trustedInputs[i]] : trustedInputs;\n\n    if (useBip143) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i],\n        script\n      }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(transport, !useBip143 && firstRun, pseudoTX, pseudoTrustedInputs, useBip143, !!expiryHeight && !isDecred, additionals, useTrustedInputForSegwit);\n\n    if (!useBip143) {\n      if (changePath) {\n        await provideOutputFullChangePath(transport, changePath);\n      }\n\n      await hashOutputFull(transport, outputScript, additionals);\n    }\n\n    if (firstRun) {\n      onDeviceSignatureGranted();\n      notify(1, 0);\n    }\n\n    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType, expiryHeight, additionals);\n    notify(1, i + 1);\n    signatures.push(signature);\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  } // Populate the final input scripts\n\n\n  for (let i = 0; i < inputs.length; i++) {\n    if (segwit) {\n      targetTransaction.witness = Buffer.alloc(0);\n\n      if (!bech32) {\n        targetTransaction.inputs[i].script = Buffer.concat([Buffer.from(\"160014\", \"hex\"), hashPublicKey(publicKeys[i])]);\n      }\n    } else {\n      const signatureSize = Buffer.alloc(1);\n      const keySize = Buffer.alloc(1);\n      signatureSize[0] = signatures[i].length;\n      keySize[0] = publicKeys[i].length;\n      targetTransaction.inputs[i].script = Buffer.concat([signatureSize, signatures[i], keySize, publicKeys[i]]);\n    }\n\n    let offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;\n    targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 0x24);\n  }\n\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32LE(lockTime, 0);\n  var result = Buffer.concat([serializeTransaction(targetTransaction, false, targetTransaction.timestamp, additionals), outputScript]);\n\n  if (segwit && !isDecred) {\n    var witness = Buffer.alloc(0);\n\n    for (var i = 0; i < inputs.length; i++) {\n      var tmpScriptData = Buffer.concat([Buffer.from(\"02\", \"hex\"), Buffer.from([signatures[i].length]), signatures[i], Buffer.from([publicKeys[i].length]), publicKeys[i]]);\n      witness = Buffer.concat([witness, tmpScriptData]);\n    }\n\n    result = Buffer.concat([result, witness]);\n  } // FIXME: In ZEC or KMD sapling lockTime is serialized before expiryHeight.\n  // expiryHeight is used only in overwinter/sapling so I moved lockTimeBuffer here\n  // and it should not break other coins because expiryHeight is false for them.\n  // Don't know about Decred though.\n\n\n  result = Buffer.concat([result, lockTimeBuffer]);\n\n  if (expiryHeight) {\n    result = Buffer.concat([result, targetTransaction.nExpiryHeight || Buffer.alloc(0), targetTransaction.extraData || Buffer.alloc(0)]);\n  }\n\n  if (isDecred) {\n    let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n    inputs.forEach((input, inputIndex) => {\n      decredWitness = Buffer.concat([decredWitness, Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n      Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n      Buffer.from([targetTransaction.inputs[inputIndex].script.length]), targetTransaction.inputs[inputIndex].script]);\n    });\n    result = Buffer.concat([result, decredWitness]);\n  }\n\n  return result.toString(\"hex\");\n}\n\nconst defaultArg = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  transactionVersion: DEFAULT_VERSION\n};\n/**\n *\n */\n\nasync function signP2SHTransaction(transport, arg) {\n  const {\n    inputs,\n    associatedKeysets,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    transactionVersion\n  } = { ...defaultArg,\n    ...arg\n  }; // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  defaultVersion.writeUInt32LE(transactionVersion, 0);\n  const trustedInputs = [];\n  const regularOutputs = [];\n  const signatures = [];\n  let firstRun = true;\n  let targetTransaction = {\n    inputs: [],\n    version: defaultVersion\n  };\n  const getTrustedInputCall = segwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n  for (let input of inputs) {\n    {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0]);\n      let sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE, 0);\n      trustedInputs.push({\n        trustedInput: false,\n        value: segwit ? Buffer.from(trustedInput, \"hex\") : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n        sequence\n      });\n    }\n\n    const {\n      outputs\n    } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n  } // Pre-build the target transaction\n\n\n  for (let i = 0; i < inputs.length; i++) {\n    let sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(inputs[i].length >= 4 && typeof inputs[i][3] === \"number\" ? inputs[i][3] : DEFAULT_SEQUENCE, 0);\n    targetTransaction.inputs.push({\n      script: nullScript,\n      prevout: nullPrevout,\n      sequence\n    });\n  }\n\n  if (segwit) {\n    await startUntrustedHashTransactionInput(transport, true, targetTransaction, trustedInputs, true);\n    await hashOutputFull(transport, outputScript);\n  }\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    let script = inputs[i].length >= 3 && typeof input[2] === \"string\" ? Buffer.from(input[2], \"hex\") : regularOutputs[i].script;\n    let pseudoTX = Object.assign({}, targetTransaction);\n    let pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n\n    if (segwit) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i],\n        script\n      }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(transport, !segwit && firstRun, pseudoTX, pseudoTrustedInputs, segwit);\n\n    if (!segwit) {\n      await hashOutputFull(transport, outputScript);\n    }\n\n    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType);\n    signatures.push(segwit ? signature.toString(\"hex\") : signature.slice(0, signature.length - 1).toString(\"hex\"));\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  return signatures;\n}\n\n/**\n * Bitcoin API.\n *\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc(transport)\n */\nclass Btc {\n  constructor(transport, scrambleKey = \"BTC\") {\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getWalletPublicKey\", \"signP2SHTransaction\", \"signMessageNew\", \"createPaymentTransactionNew\", \"getTrustedInput\", \"getTrustedInputBIP143\"], scrambleKey);\n  }\n  /**\n   * @param path a BIP 32 path\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) will ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 173' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n\n\n  getWalletPublicKey(path, opts) {\n    let options;\n\n    if (arguments.length > 2 || typeof opts === \"boolean\") {\n      console.warn(\"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\");\n      options = {\n        verify: !!opts,\n        format: arguments[2] ? \"p2sh\" : \"legacy\"\n      };\n    } else {\n      options = opts || {};\n    }\n\n    return getWalletPublicKey(this.transport, { ...options,\n      path\n    });\n  }\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessageNew_async(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n\n\n  signMessageNew(path, messageHex) {\n    return signMessage(this.transport, {\n      path,\n      messageHex\n    });\n  }\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n\n\n  createPaymentTransactionNew(arg) {\n    if (arguments.length > 1) {\n      console.warn(\"@ledgerhq/hw-app-btc: createPaymentTransactionNew multi argument signature is deprecated. please switch to named parameters.\");\n      arg = fromDeprecateArguments(arguments, [\"inputs\", \"associatedKeysets\", \"changePath\", \"outputScriptHex\", \"lockTime\", \"sigHashType\", \"segwit\", \"initialTimestamp\", \"additionals\", \"expiryHeight\", \"useTrustedInputForSegwit\"]);\n    }\n\n    return createTransaction(this.transport, arg);\n  }\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.signP2SHTransaction({\n  inputs: [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n  associatedKeysets: [\"0'/0/0\"],\n  outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(result => ...);\n   */\n\n\n  signP2SHTransaction(arg) {\n    if (arguments.length > 1) {\n      console.warn(\"@ledgerhq/hw-app-btc: signP2SHTransaction multi argument signature is deprecated. please switch to named parameters.\");\n      const [inputs, associatedKeysets, outputScriptHex, lockTime, sigHashType, segwit, transactionVersion] = arguments;\n      arg = {\n        inputs,\n        associatedKeysets,\n        outputScriptHex,\n        lockTime,\n        sigHashType,\n        segwit,\n        transactionVersion\n      };\n      arg = fromDeprecateArguments(arguments, [\"inputs\", \"associatedKeysets\", \"outputScriptHex\", \"lockTime\", \"sigHashType\", \"segwit\", \"transactionVersion\"]);\n    }\n\n    return signP2SHTransaction(this.transport, arg);\n  }\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n\n\n  splitTransaction(transactionHex, isSegwitSupported = false, hasTimestamp = false, hasExtraData = false, additionals = []) {\n    return splitTransaction(transactionHex, isSegwitSupported, hasTimestamp, hasExtraData, additionals);\n  }\n  /**\n  @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n  const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n\n\n  serializeTransactionOutputs(t) {\n    return serializeTransactionOutputs(t);\n  }\n\n  getTrustedInput(indexLookup, transaction, additionals = []) {\n    return getTrustedInput(this.transport, indexLookup, transaction, additionals);\n  }\n\n  getTrustedInputBIP143(indexLookup, transaction, additionals = []) {\n    return getTrustedInputBIP143(this.transport, indexLookup, transaction, additionals);\n  }\n\n}\n\nfunction fromDeprecateArguments(args, keys) {\n  const obj = {};\n  keys.forEach((key, i) => {\n    const value = args[i];\n\n    if (value !== undefined) {\n      obj[key] = value;\n    }\n  });\n  return obj;\n}\n//# sourceMappingURL=Btc.js.map\n\nexport default Btc;\n//# sourceMappingURL=lazy-chunk-Btc.es.js.map\n"],"sourceRoot":""}