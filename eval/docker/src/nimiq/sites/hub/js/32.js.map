{"version":3,"sources":["sources://./node_modules/@nimiq/ledger-api/dist/high-level-api/lazy-chunk-request-get-extended-public-key-bitcoin.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsE;AACG;AACmC;AACxE;;AAEpC;AACA;AACA;AACA;AACA,WAAW,WAAW,UAAU,kNAAiD,EAAE,+LAAmC,EAAE,iQAAmC,EAAE,kNAA6C,EAAE,6NAAkD,EAAE,8LAAmC,EAAE,2QAAwC;AAC7U;AACA,SAAS,yDAAO;AAChB,SAAS,yDAAO;AAChB,KAAK;AACL;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,SAAS,oEAAkB;AAC3B,aAAa,yDAAO;AACpB,aAAa,yDAAO;AACpB,SAAS;AACT,SAAS,oEAAkB;AAC3B,aAAa,yDAAO;AACpB;AACA;AACA,aAAa;AACb,aAAa,yDAAO;AACpB;AACA;AACA,aAAa;AACb,SAAS;AACT,SAAS,oEAAkB;AAC3B,aAAa,yDAAO;AACpB;AACA;AACA,aAAa;AACb,aAAa,yDAAO;AACpB;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK,uBAAuB;AAC5B;AACA,6DAA6D,QAAQ,iBAAiB,YAAY;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,8BAA8B;AAC9B,iCAAiC;AACjC,mCAAmC;AACnC;AACA,iDAAiD,mEAAc;AAC/D;AACA;AACA,oBAAoB,oEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS,8CAA8C,QAAQ;AAChG;AACA;AACA;AACA;AACA,gBAAgB,oEAAkB;AAClC,gBAAgB,oEAAkB;AAClC,gBAAgB,oEAAkB;AAClC,SAAS;AACT;AACA,eAAe,yDAAO;AACtB,eAAe,yDAAO;AACtB,SAAS;AACT;AACA,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,uBAAuB,6DAA6D;AACpF,uBAAuB,iDAAiD;AACxE,uBAAuB,yEAAyE,mCAAmC,aAAa,GAAG,iBAAiB;AACpK;AACA,oBAAoB,wEAAM;AAC1B,oBAAoB,wEAAM;AAC1B,oBAAoB,wEAAM;AAC1B,oBAAoB,wEAAM;AAC1B,oBAAoB,wEAAM;AAC1B,oBAAoB,wEAAM;AAC1B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU,CAAC,2DAAS;AAC1C;AACA;AACA;;AAEe,iGAAkC,EAAC;AAClD","file":"js/32.js","sourcesContent":["import { B as Buffer } from './lazy-chunk-polyfill-node:buffer.es.js';\nimport { R as RequestBitcoin } from './lazy-chunk-request-bitcoin.es.js';\nimport { Network, AddressTypeBitcoin, RequestTypeBitcoin, ErrorState, ErrorType } from './ledger-api.es.js';\nimport './lazy-chunk-request.es.js';\n\n// TODO if in the future the interchangeability of bitcoin-lib with the Nimiq hub's BitcoinJS is not needed anymore,\n//  this can move directly into the lazy loaded bitcoin-lib and then also be lazy loaded.\nasync function getNetworkInfo(network, addressType) {\n    // async because bitcoin-lib is lazy loaded\n    const { networks } = await [import('./lazy-chunk-polyfill-node:buffer.es.js'), import('./lazy-chunk-sha256.es.js'), import('./lazy-chunk-index.es4.js'), import('./lazy-chunk-_commonjsHelpers.es.js'), import('./lazy-chunk-polyfill-node:process.es.js'), import('./lazy-chunk-events.es.js'), import('./lazy-chunk-bitcoin-lib.es.js')][6];\n    const result = {\n        [Network.MAINNET]: networks.bitcoin,\n        [Network.TESTNET]: networks.testnet,\n    }[network];\n    if (!result)\n        throw new Error(`Unsupported network ${network}`);\n    // Bip32 version bytes for different address types which are not all defined by the bip32 lib,\n    // see https://github.com/satoshilabs/slips/blob/master/slip-0132.md#registered-hd-version-bytes\n    const versionBytes = {\n        [AddressTypeBitcoin.LEGACY]: {\n            [Network.MAINNET]: networks.bitcoin.bip32,\n            [Network.TESTNET]: networks.testnet.bip32,\n        },\n        [AddressTypeBitcoin.P2SH_SEGWIT]: {\n            [Network.MAINNET]: {\n                public: 0x049d7cb2,\n                private: 0x049d7878,\n            },\n            [Network.TESTNET]: {\n                public: 0x044a5262,\n                private: 0x044a4e28,\n            },\n        },\n        [AddressTypeBitcoin.NATIVE_SEGWIT]: {\n            [Network.MAINNET]: {\n                public: 0x04b24746,\n                private: 0x04b2430c,\n            },\n            [Network.TESTNET]: {\n                public: 0x045f1cf6,\n                private: 0x045f18bc,\n            },\n        },\n    }[addressType][network]; // TODO should be using optional chaining here once we update rollup\n    if (!versionBytes)\n        throw new Error(`Unknown version bytes for network ${network}, address type ${addressType}`);\n    return {\n        ...result,\n        bip32: versionBytes,\n    };\n}\n// Taken from https://github.com/LedgerHQ/ledger-wallet-webtool/blob/master/src/PathFinderUtils.js#L31\n// Also see https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/compressPublicKey.js for a version\n// operating on buffers. However, usage requires then loading the Buffer polyfill.\nfunction compressPublicKey(publicKey) {\n    let compressedKeyIndex;\n    if (publicKey.substring(0, 2) !== '04') {\n        throw new Error('Invalid public key format');\n    }\n    if (parseInt(publicKey.substring(128, 130), 16) % 2 !== 0) {\n        compressedKeyIndex = '03';\n    }\n    else {\n        compressedKeyIndex = '02';\n    }\n    return compressedKeyIndex + publicKey.substring(2, 66);\n}\n//# sourceMappingURL=bitcoin-utils.js.map\n\nconst KEY_PATH_REGEX = new RegExp('^'\n    + '(?:m/)?' // optional m/ prefix\n    + '(44|49|84)\\'' // purpose id; BIP44 (BTC legacy) / BIP49 (BTC nested SegWit) / BIP84 (BTC native SegWit)\n    + '/(0|1)\\'' // coin type; 0 for Bitcoin Mainnet, 1 for Bitcoin Testnet\n    + '/\\\\d+\\'' // account index; allow only xpubs for specific accounts\n    + '(?:/\\\\d+\\'?)*' // sub paths; No constraints as they can be circumvented anyway by deriving from higher level xpub\n    + '$');\nclass RequestGetExtendedPublicKeyBitcoin extends RequestBitcoin {\n    constructor(keyPath, expectedWalletId) {\n        super(expectedWalletId);\n        this.type = RequestTypeBitcoin.GET_EXTENDED_PUBLIC_KEY;\n        this.keyPath = keyPath;\n        // Check for keyPath validity. Not using parseBip32Path from bip32-utils as we allow exporting xpubs at\n        // arbitrary levels. Further restrictions could be circumvented anyways by deriving from higher level xpub.\n        const keyPathMatch = keyPath.match(KEY_PATH_REGEX);\n        if (!keyPathMatch) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}. Paths must follow bip44 and at least specify the purpose id`\n                + ' (allowed are 44\\', 49\\', 84\\'), coin type (allowed are 0\\', 1\\') and account index (hardened).', this);\n        }\n        const [, purposeId, networkId] = keyPathMatch;\n        this._addressType = {\n            44: AddressTypeBitcoin.LEGACY,\n            49: AddressTypeBitcoin.P2SH_SEGWIT,\n            84: AddressTypeBitcoin.NATIVE_SEGWIT,\n        }[purposeId];\n        this.network = {\n            0: Network.MAINNET,\n            1: Network.TESTNET,\n        }[networkId];\n        // Preload bitcoin lib. Ledger Bitcoin api is already preloaded by parent class. Ignore errors.\n        this._loadBitcoinLib().catch(() => { });\n    }\n    async call(transport) {\n        // Build xpub as specified in bip32\n        // (https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format)\n        const verificationPath = '0/0';\n        // Note: We make api calls outside of the try...catch block to let the exceptions fall through such that\n        // _callLedger can decide how to behave depending on the api error. Load errors are converted to\n        // LOADING_DEPENDENCIES_FAILED error states by _getLowLevelApi and _LoadBitcoinLib. All other errors\n        // are converted to REQUEST_ASSERTION_FAILED errors which stop the execution of the request.\n        const [{ bip32 }, [parentPubKey, parentChainCode, pubKey, chainCode, verificationPubKey, verificationChainCode],] = await Promise.all([\n            this._loadBitcoinLib(),\n            (async () => {\n                // Fetch the data from Ledger required for xpub calculation\n                // TODO Requesting the public key causes a confirmation screen to be displayed on the Ledger for u2f and\n                //  WebAuthn for every request if the user has this privacy feature enabled in the Bitcoin app.\n                //  Subsequent requests can provide a permission token in _getLowLevelApi to avoid this screen (see\n                //  https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc#get-wallet-public-key). This token\n                //  is however not supported in @ledgerhq/hw-app-btc and therefore has to be implemented by ourselves.\n                const api = await this._getLowLevelApi(transport); // throws LOADING_DEPENDENCIES_FAILED\n                const parentPath = this.keyPath.substring(0, this.keyPath.lastIndexOf('/'));\n                // ledger requests have to be sent sequentially as ledger can only perform one request at a time\n                const { publicKey: parentPubKeyHex, chainCode: parentChainCodeHex, } = await api.getWalletPublicKey(parentPath);\n                const { publicKey: pubKeyHex, chainCode: chainCodeHex, } = await api.getWalletPublicKey(this.keyPath);\n                const { publicKey: verificationPubKeyHex, chainCode: verificationChainCodeHex, } = await api.getWalletPublicKey(`${this.keyPath}/${verificationPath}`);\n                return [\n                    Buffer.from(compressPublicKey(parentPubKeyHex), 'hex'),\n                    Buffer.from(parentChainCodeHex, 'hex'),\n                    Buffer.from(compressPublicKey(pubKeyHex), 'hex'),\n                    Buffer.from(chainCodeHex, 'hex'),\n                    Buffer.from(compressPublicKey(verificationPubKeyHex), 'hex'),\n                    Buffer.from(verificationChainCodeHex, 'hex'),\n                ];\n            })(),\n        ]);\n        try {\n            // Note getNetworkInfo is only async because it lazy loads the bitcoin lib, which is already loaded at this\n            // point. Therefore putting it into the Promise.all has no further upside and errors within the call should\n            // become REQUEST_ASSERTION_FAILED exceptions.\n            const networkInfo = await getNetworkInfo(this.network, this._addressType);\n            const parent = bip32.fromPublicKey(parentPubKey, parentChainCode, networkInfo);\n            const parentFingerprint = parent.fingerprint.readUInt32BE(0); // this is calculated from the pub key only\n            const keyPathParts = this.keyPath.split('/');\n            const depth = keyPathParts.length;\n            const index = Number.parseInt(keyPathParts[depth - 1], 10)\n                + (this.keyPath.endsWith('\\'') ? 0x80000000 : 0); // set index for hardened paths according to bip32\n            // Create the xpub from the data we collected. Unfortunately, the bip32 lib does not expose the generic\n            // constructor, such that we have to set some private properties manually. But we try to do it in a future\n            // proof and minification safe manner.\n            // TODO make this less hacky\n            /* eslint-disable dot-notation */\n            /* eslint-disable @typescript-eslint/dot-notation */\n            const extendedPubKey = bip32.fromPublicKey(pubKey, chainCode, networkInfo);\n            if (extendedPubKey.__DEPTH === 0) {\n                extendedPubKey.__DEPTH = depth;\n            }\n            else if (extendedPubKey['__DEPTH'] === 0) {\n                extendedPubKey['__DEPTH'] = depth;\n            }\n            else {\n                throw new Error('Failed to construct xpub, couldn\\'t set __DEPTH.');\n            }\n            if (extendedPubKey.__INDEX === 0) {\n                extendedPubKey.__INDEX = index;\n            }\n            else if (extendedPubKey['__INDEX'] === 0) {\n                extendedPubKey['__INDEX'] = index;\n            }\n            else {\n                throw new Error('Failed to construct xpub, couldn\\'t set __INDEX.');\n            }\n            if (extendedPubKey.__PARENT_FINGERPRINT === 0) {\n                extendedPubKey.__PARENT_FINGERPRINT = parentFingerprint;\n            }\n            else if (extendedPubKey['__PARENT_FINGERPRINT'] === 0) {\n                extendedPubKey['__PARENT_FINGERPRINT'] = parentFingerprint;\n            }\n            else {\n                throw new Error('Failed to construct xpub, couldn\\'t set __PARENT_FINGERPRINT.');\n            }\n            /* eslint-enable dot-notation */\n            /* eslint-enable @typescript-eslint/dot-notation */\n            // Verify that the generated xpub is correct by deriving an example child and comparing it to the result\n            // calculated by the Ledger device. Do not verify the Ledger generated address as it is derived from the\n            // pub key anyways.\n            const verificationDerivation = extendedPubKey.derivePath(verificationPath);\n            if (!verificationDerivation.publicKey.equals(verificationPubKey)\n                || !verificationDerivation.chainCode.equals(verificationChainCode)) {\n                throw new Error('Failed to verify the constructed xpub.');\n            }\n            return extendedPubKey.toBase58();\n        }\n        catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, e, this);\n        }\n    }\n}\n\nexport default RequestGetExtendedPublicKeyBitcoin;\n//# sourceMappingURL=lazy-chunk-request-get-extended-public-key-bitcoin.es.js.map\n"],"sourceRoot":""}